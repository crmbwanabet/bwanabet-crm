<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BetAssist AI - Personalized Sports Betting Assistant</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @keyframes typing-dot {
      0%, 60%, 100% { transform: translateY(0); opacity: 0.5; }
      30% { transform: translateY(-4px); opacity: 1; }
    }
    .typing-dot { animation: typing-dot 1.4s infinite ease-in-out; }
    .typing-dot:nth-child(1) { animation-delay: 0s; }
    .typing-dot:nth-child(2) { animation-delay: 0.2s; }
    .typing-dot:nth-child(3) { animation-delay: 0.4s; }
    
    @keyframes message-appear {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .message-appear { animation: message-appear 0.3s ease-out; }
    
    .chat-scroll::-webkit-scrollbar { width: 6px; }
    .chat-scroll::-webkit-scrollbar-track { background: transparent; }
    .chat-scroll::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }

    .game-card {
      background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
    }
    
    /* Clickable recommendation buttons */
    .quick-action {
      display: inline-block;
      padding: 8px 16px;
      margin: 4px;
      background: linear-gradient(135deg, #1e3a5f 0%, #0f172a 100%);
      border: 1px solid #3b82f6;
      border-radius: 20px;
      color: #60a5fa;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .quick-action:hover {
      background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
      color: white;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    }
    .quick-action:active {
      transform: translateY(0);
    }
    .quick-actions-container {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid #334155;
    }
    
    /* Expandable "More Info" dropdown */
    .more-info {
      margin-top: 10px;
      border-top: 1px solid #334155;
      padding-top: 8px;
    }
    .more-info summary {
      cursor: pointer;
      color: #60a5fa;
      font-size: 12px;
      padding: 6px 0;
      list-style: none;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .more-info summary::-webkit-details-marker {
      display: none;
    }
    .more-info summary::before {
      content: '+';
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      border: 1px solid #3b82f6;
      border-radius: 50%;
      font-size: 12px;
      font-weight: bold;
      transition: all 0.2s ease;
    }
    .more-info[open] summary::before {
      content: '-';
      background: #3b82f6;
      color: white;
    }
    .more-info summary:hover {
      color: #93c5fd;
    }
    .more-info-content {
      padding: 8px 0 4px 22px;
      font-size: 12px;
      color: #94a3b8;
      line-height: 1.5;
    }
  </style>
</head>
<body class="bg-slate-900 min-h-screen">

  <!-- Main App -->
  <div id="mainApp">
    <!-- Header -->
    <div class="fixed top-0 left-0 right-0 bg-slate-800 border-b border-slate-700 px-4 py-3 z-40">
      <div class="max-w-2xl mx-auto flex items-center justify-between">
        <div class="flex items-center gap-3">
          <div class="w-10 h-10 rounded-xl bg-gradient-to-br from-amber-400 to-orange-500 flex items-center justify-center">
            <span class="text-xl"></span>
          </div>
          <div>
            <h1 class="font-bold text-white">BetAssist AI</h1>
            <div class="flex items-center gap-1">
              <div class="w-2 h-2 rounded-full bg-emerald-400 animate-pulse"></div>
              <span class="text-xs text-slate-400">Personalized Sports Betting AI</span>
            </div>
          </div>
        </div>
        <div class="flex gap-2">
          <button onclick="clearChat()" class="text-slate-400 hover:text-white p-2 rounded-lg hover:bg-slate-700" title="Clear chat">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
            </svg>
          </button>
        </div>
      </div>
    </div>

    <!-- Chat Container -->
    <div class="max-w-2xl mx-auto pt-20 pb-40 px-4">
      <div id="messages" class="space-y-4"></div>
      
      <!-- Typing Indicator with Progress Bar -->
      <div id="typingIndicator" class="hidden p-4">
        <div class="flex items-center gap-2 mb-2">
          <div class="w-8 h-8 rounded-full bg-gradient-to-r from-amber-400 to-orange-500 flex items-center justify-center">
            <span class="text-sm"></span>
          </div>
          <div class="flex gap-1">
            <div class="w-2 h-2 bg-slate-400 rounded-full typing-dot"></div>
            <div class="w-2 h-2 bg-slate-400 rounded-full typing-dot"></div>
            <div class="w-2 h-2 bg-slate-400 rounded-full typing-dot"></div>
          </div>
          <span id="typingStatus" class="text-xs text-slate-400 ml-2"></span>
        </div>
        <!-- Progress bar (hidden initially, shows after 2 seconds) -->
        <div id="progressContainer" class="hidden mt-1 ml-10">
          <div class="flex items-center gap-2">
            <div class="w-20 h-0.5 bg-slate-700 rounded-full overflow-hidden">
              <div id="progressBar" class="h-full bg-slate-400 rounded-full transition-all duration-200" style="width: 0%"></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Input Area -->
    <div class="fixed bottom-0 left-0 right-0 bg-slate-900 border-t border-slate-700 p-4">
      <div class="max-w-2xl mx-auto">
        <!-- Input -->
        <div class="flex gap-3">
          <input 
            type="text" 
            id="messageInput" 
            placeholder="Ask about matches, tips, betting, casino..." 
            class="flex-1 bg-slate-800 text-white placeholder-slate-400 rounded-xl px-4 py-3 focus:outline-none focus:ring-2 focus:ring-amber-500 border border-slate-700"
            onkeydown="if(event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); sendMessage(); }"
          >
          <button 
            onclick="sendMessage()" 
            id="sendButton"
            class="px-6 py-3 bg-gradient-to-r from-amber-500 to-orange-500 hover:from-amber-600 hover:to-orange-600 text-white font-semibold rounded-xl transition-all disabled:opacity-50 disabled:cursor-not-allowed"
          >
            Send
          </button>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    // ============================================
    //  CONFIGURATION - ADD YOUR API KEYS HERE
    // ============================================
    // Version: 2.1 - Quick Actions Update
    
    //  CLAUDE API KEY - Now stored in Supabase Edge Function (more secure!)
    // You'll set this in Supabase secrets, not here
    const HARDCODED_API_KEY = 'not-needed-using-proxy';
    
    // ============================================
    //  SUPABASE DATABASE (OPTIONAL - for testing)
    // ============================================
    
    const SUPABASE_CONFIG = {
      url: 'https://dumjacmxefrxzcccsyxj.supabase.co',
      anonKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImR1bWphY214ZWZyeHpjY2NzeXhqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njg0NjgwNTgsImV4cCI6MjA4NDA0NDA1OH0.lpzyMwI9Vds91FXm2oxK9Q8OpOYy-uSs3pWKdcx3Rd8',
      enabled: true,
      // Edge Function URL for Claude API proxy
      claudeProxyUrl: 'https://dumjacmxefrxzcccsyxj.supabase.co/functions/v1/smart-processor',
    };

    // Supabase client instance
    let supabaseClient = null;
    let currentPlayerId = null;

    // ============================================
    //  BUG FIXES - Caching, Rate Limiting, etc.
    // ============================================
    
    // API Response Cache (prevents redundant API calls)
    const apiCache = new Map();
    const CACHE_TTL = 60000; // 1 minute cache
    
    // Rate limiting for messages
    let lastMessageTime = 0;
    const MESSAGE_COOLDOWN = 1500; // 1.5 seconds between messages
    
    // Debounced save
    let saveTimeout = null;
    const SAVE_DEBOUNCE = 5000; // 5 seconds
    
    // Session tracking
    const sessionStart = Date.now();
    let sessionWarningShown = false;

    // ============================================
    // ENGAGEMENT FEATURES - Subtle conversion drivers
    // ============================================
    
    // ============================================
    // USER MODE - Beginner (simple) vs Pro (jargon)
    // ============================================
    
    let userMode = 'beginner'; // 'beginner' or 'pro'
    let userPreference = null; // 'sports' or 'casino' or null
    
    function setUserMode(mode) {
      userMode = mode;
      console.log('User mode set to:', mode);
    }
    
    function setUserPreference(pref) {
      userPreference = pref;
      console.log('User preference set to:', pref);
    }
    
    // Betting terminology - Plain English translations
    const BETTING_TERMS = {
      '1': { jargon: '1', simple: 'Home team wins' },
      'X': { jargon: 'X', simple: 'Draw (tie game)' },
      '2': { jargon: '2', simple: 'Away team wins' },
      '1X': { jargon: '1X', simple: 'Home team wins OR draw' },
      'X2': { jargon: 'X2', simple: 'Away team wins OR draw' },
      '12': { jargon: '12', simple: 'Either team wins (no draw)' },
      'over_2.5': { jargon: 'Over 2.5', simple: '3 or more goals' },
      'under_2.5': { jargon: 'Under 2.5', simple: '2 or fewer goals' },
      'over_1.5': { jargon: 'Over 1.5', simple: '2 or more goals' },
      'under_1.5': { jargon: 'Under 1.5', simple: '1 or no goals' },
      'over_3.5': { jargon: 'Over 3.5', simple: '4 or more goals' },
      'under_3.5': { jargon: 'Under 3.5', simple: '3 or fewer goals' },
      'btts_yes': { jargon: 'BTTS Yes', simple: 'Both teams score at least 1 goal' },
      'btts_no': { jargon: 'BTTS No', simple: 'At least one team scores 0 goals' },
      'clean_sheet': { jargon: 'Clean Sheet', simple: 'Team allows 0 goals' },
      'handicap': { jargon: 'Handicap', simple: 'Team starts with goal advantage/disadvantage' },
      'double_chance': { jargon: 'Double Chance', simple: '2 outcomes covered in 1 bet' },
      'gg': { jargon: 'GG', simple: 'Both teams score (Goal-Goal)' },
      'ng': { jargon: 'NG', simple: 'At least one team scores 0 (No Goal)' },
    };
    
    // Format betting term based on user mode
    function formatBetTerm(termKey, homeTeam = 'Home', awayTeam = 'Away') {
      const term = BETTING_TERMS[termKey];
      if (!term) return termKey;
      
      if (userMode === 'beginner') {
        let simple = term.simple;
        simple = simple.replace('Home team', homeTeam);
        simple = simple.replace('Away team', awayTeam);
        return `${term.jargon} (${simple})`;
      }
      return term.jargon;
    }
    
    // Confidence labels instead of percentages for beginners
    function formatConfidence(percentage) {
      if (userMode === 'pro') {
        return `${percentage}%`;
      }
      
      // Beginner-friendly labels
      if (percentage >= 75) return 'Very Likely';
      if (percentage >= 65) return 'Likely';
      if (percentage >= 55) return 'Possible';
      if (percentage >= 45) return 'Risky';
      return 'Very Risky';
    }
    
    // Format recommendation with explanation
    function formatRecommendation(pick, percentage, reasoning, homeTeam = '', awayTeam = '') {
      let response = '';
      
      if (userMode === 'beginner') {
        const confidence = formatConfidence(percentage);
        response += `**My Pick:** ${pick}\n`;
        response += `**Confidence:** ${confidence}\n\n`;
        response += `**Why?** ${reasoning}\n`;
      } else {
        response += `**Pick:** ${pick} - ${percentage}%\n`;
        response += `**Analysis:** ${reasoning}\n`;
      }
      
      return response;
    }
    
    // Live betting activity simulation (realistic numbers)
    const engagementData = {
      // Live bet counters - fluctuate realistically
      liveBetters: {
        base: 127,
        variance: 45,
        lastUpdate: Date.now(),
        currentCount: 127,
      },
      
      // Trending picks - rotates based on time
      trendingPicks: [
        { match: 'Liverpool vs Man City', pick: 'Over 2.5 Goals', betters: 234, trend: 'hot' },
        { match: 'Arsenal vs Chelsea', pick: 'Both Teams Score', betters: 189, trend: 'rising' },
        { match: 'Real Madrid vs Barcelona', pick: 'Real Madrid Win', betters: 312, trend: 'hot' },
        { match: 'Lakers vs Celtics', pick: 'Over 215.5 Points', betters: 156, trend: 'rising' },
        { match: 'Man United vs Tottenham', pick: 'Double Chance 1X', betters: 178, trend: 'stable' },
      ],
      
      // Bonus urgency timers
      bonuses: {
        freeBet: { amount: 25, expiresIn: 7200000, label: 'Free Bet' }, // 2 hours in ms
        depositMatch: { amount: 50, expiresIn: 14400000, label: '100% Deposit Match' }, // 4 hours
        riskFree: { amount: 100, expiresIn: 3600000, label: 'Risk-Free Bet' }, // 1 hour
      },
      
      // Recent wins (social proof)
      recentWins: [
        { player: 'Bwana M.', amount: 2450, bet: '5-pick betslip', time: 12 },
        { player: 'Bwana K.', amount: 890, bet: 'Liverpool Win', time: 8 },
        { player: 'Bwana S.', amount: 3200, bet: 'Aviator cashout', time: 15 },
        { player: 'Bwana J.', amount: 1560, bet: 'Over 2.5 Goals', time: 5 },
      ],
    };
    
    // Get live betters count (fluctuates realistically)
    function getLiveBettersCount(matchContext = null) {
      const now = Date.now();
      const timeSinceUpdate = now - engagementData.liveBetters.lastUpdate;
      
      // Update every 30 seconds with realistic fluctuation
      if (timeSinceUpdate > 30000) {
        const change = Math.floor(Math.random() * 20) - 8; // -8 to +12 (slight upward bias)
        engagementData.liveBetters.currentCount = Math.max(50, 
          Math.min(300, engagementData.liveBetters.currentCount + change));
        engagementData.liveBetters.lastUpdate = now;
      }
      
      // Add match-specific boost
      if (matchContext) {
        const boost = Math.floor(Math.random() * 30) + 10;
        return engagementData.liveBetters.currentCount + boost;
      }
      
      return engagementData.liveBetters.currentCount;
    }
    
    // Get trending pick for current context
    function getTrendingPick(league = null) {
      const picks = engagementData.trendingPicks;
      
      // Filter by league if provided
      if (league) {
        const leaguePicks = picks.filter(p => 
          p.match.toLowerCase().includes(league.toLowerCase())
        );
        if (leaguePicks.length > 0) {
          return leaguePicks[Math.floor(Math.random() * leaguePicks.length)];
        }
      }
      
      // Return hottest pick
      const hotPicks = picks.filter(p => p.trend === 'hot');
      return hotPicks.length > 0 ? hotPicks[0] : picks[0];
    }
    
    // Get countdown string for match
    function getMatchCountdown(matchTime) {
      if (!matchTime) return null;
      
      const now = new Date();
      const match = new Date(matchTime);
      const diffMs = match - now;
      
      if (diffMs < 0) return 'LIVE NOW';
      
      const diffMins = Math.floor(diffMs / 60000);
      const diffHours = Math.floor(diffMins / 60);
      
      if (diffMins < 60) {
        return `${diffMins} min`;
      } else if (diffHours < 24) {
        const mins = diffMins % 60;
        return mins > 0 ? `${diffHours}h ${mins}m` : `${diffHours}h`;
      } else {
        const days = Math.floor(diffHours / 24);
        return `${days}d ${diffHours % 24}h`;
      }
    }
    
    // Get bonus with urgency
    function getActiveBonus() {
      const bonuses = engagementData.bonuses;
      const now = Date.now();
      
      // Randomly select a bonus and calculate remaining time
      const bonusTypes = Object.keys(bonuses);
      const selectedType = bonusTypes[Math.floor(Math.random() * bonusTypes.length)];
      const bonus = bonuses[selectedType];
      
      // Calculate "remaining time" (resets each session for demo)
      const sessionElapsed = now - sessionStart;
      const remaining = Math.max(0, bonus.expiresIn - sessionElapsed);
      
      if (remaining <= 0) return null;
      
      const hours = Math.floor(remaining / 3600000);
      const mins = Math.floor((remaining % 3600000) / 60000);
      
      return {
        label: bonus.label,
        amount: bonus.amount,
        timeLeft: hours > 0 ? `${hours}h ${mins}m` : `${mins} minutes`,
        urgent: remaining < 3600000, // Less than 1 hour
      };
    }
    
    // Get recent winner for social proof
    function getRecentWinner() {
      const winners = engagementData.recentWins;
      const winner = winners[Math.floor(Math.random() * winners.length)];
      return {
        ...winner,
        time: Math.floor(Math.random() * 20) + 2, // 2-22 minutes ago
      };
    }
    
    // Format engagement context for AI
    function getEngagementContext(matchContext = null, league = null) {
      const liveBetters = getLiveBettersCount(matchContext);
      const trending = getTrendingPick(league);
      const bonus = getActiveBonus();
      const recentWin = getRecentWinner();
      
      return {
        liveBetters,
        trending,
        bonus,
        recentWin,
        // Pre-formatted strings for AI to use
        liveBettersText: `${liveBetters} players betting now`,
        trendingText: trending ? `Trending: ${trending.pick} on ${trending.match} (${trending.betters} bets)` : null,
        bonusText: bonus ? `${bonus.label}: ZMW ${bonus.amount} - expires in ${bonus.timeLeft}${bonus.urgent ? ' [EXPIRING SOON]' : ''}` : null,
        recentWinText: `${recentWin.player} won ZMW ${recentWin.amount.toLocaleString()} on ${recentWin.bet} (${recentWin.time}m ago)`,
      };
    }

    // ============================================
    // USER MEMORY & CONTEXT TRACKING
    // ============================================
    
    const userMemory = {
      experienceLevel: null, // 'beginner', 'intermediate', 'experienced'
      currentGoal: null, // 'learn', 'place_bet', 'explore', 'casino'
      lastTopic: null, // 'sports', 'casino', 'betting_terms', 'how_to'
      lastTeamMentioned: null,
      lastLeagueMentioned: null,
      lastGameMentioned: null,
      questionsAsked: [],
      betsDiscussed: [],
      sessionFlow: [], // tracks conversation flow
    };
    
    function updateUserMemory(message, response, topic) {
      const msg = message.toLowerCase();
      
      // Detect experience level
      if (msg.includes('new to betting') || msg.includes('never bet') || msg.includes('first time') || msg.includes('how does betting work')) {
        userMemory.experienceLevel = 'beginner';
      } else if (msg.includes('know how to bet') || msg.includes('experienced') || msg.includes('regular')) {
        userMemory.experienceLevel = 'experienced';
      }
      
      // Detect current goal
      if (msg.includes('place a bet') || msg.includes('place bet') || msg.includes('want to bet')) {
        userMemory.currentGoal = 'place_bet';
      } else if (msg.includes('how') || msg.includes('what is') || msg.includes('explain') || msg.includes('learn')) {
        userMemory.currentGoal = 'learn';
      } else if (msg.includes('casino') || msg.includes('aviator') || msg.includes('slots') || msg.includes('blackjack')) {
        userMemory.currentGoal = 'casino';
      }
      
      // Track topic
      userMemory.lastTopic = topic;
      
      // Track teams mentioned
      const teams = ['liverpool', 'manchester', 'arsenal', 'chelsea', 'tottenham', 'barcelona', 'real madrid', 'juventus', 'bayern', 'lakers', 'celtics'];
      teams.forEach(team => {
        if (msg.includes(team)) userMemory.lastTeamMentioned = team;
      });
      
      // Track leagues
      const leagues = { 'premier': 'Premier League', 'la liga': 'La Liga', 'serie a': 'Serie A', 'bundesliga': 'Bundesliga', 'nba': 'NBA' };
      Object.keys(leagues).forEach(key => {
        if (msg.includes(key)) userMemory.lastLeagueMentioned = leagues[key];
      });
      
      // Track casino games
      const games = ['aviator', 'blackjack', 'roulette', 'slots', 'baccarat', 'crazy time', 'plinko'];
      games.forEach(game => {
        if (msg.includes(game)) userMemory.lastGameMentioned = game;
      });
      
      // Track flow
      userMemory.sessionFlow.push({ message: msg.substring(0, 50), topic, timestamp: Date.now() });
      if (userMemory.sessionFlow.length > 20) userMemory.sessionFlow.shift();
    }
    
    function getContextualNextSteps(topic, userMessage) {
      const msg = userMessage.toLowerCase();
      const memory = userMemory;
      
      // Based on what user asked + memory, suggest next steps
      const nextSteps = {
        // After explaining how to place a bet
        'how_to_bet': [
          { text: 'Find safe picks', action: 'give me safe Premier League picks for today' },
          { text: 'Walk me through', action: 'walk me through placing my first bet step by step' },
          { text: 'What sports?', action: 'what sports can I bet on' },
          { text: 'Play casino', action: 'recommend a beginner-friendly casino game with strategy' },
        ],
        // After explaining a betting term
        'betting_term': [
          { text: 'Get picks now', action: 'give me Premier League picks for today' },
          { text: 'Other bet types', action: 'what other bet types are there' },
          { text: 'Safest option', action: 'what is the safest bet I can make today' },
          { text: 'Play casino', action: 'recommend an easy casino game' },
        ],
        // After showing sports picks
        'sports_picks': [
          { text: 'More picks', action: 'show me more picks for today' },
          { text: 'Safer options', action: 'show me lower risk betting options' },
          { text: 'Higher payout', action: 'show me higher payout bets' },
          { text: 'Different league', action: 'show me picks for La Liga' },
        ],
        // After casino game explanation
        'casino_game': [
          { text: 'More strategies', action: 'give me more winning strategies for this game' },
          { text: 'Other games', action: 'what other casino games have good odds' },
          { text: 'Sports instead', action: 'give me sports picks instead' },
          { text: 'Best odds game', action: 'which casino game has the best payout rate' },
        ],
        // After deposit/withdrawal info
        'account_help': [
          { text: 'Get started', action: 'give me Premier League picks to start betting' },
          { text: 'My bonuses', action: 'check what bonuses I have available' },
          { text: 'More help', action: 'what else can you help me with' },
          { text: 'Play casino', action: 'recommend an easy casino game' },
        ],
        // Default / greeting
        'default': [
          { text: 'Today\'s picks', action: 'give me today\'s best Premier League picks' },
          { text: 'Play casino', action: 'recommend a casino game with winning strategy' },
          { text: 'Use bonus', action: 'help me use my bonus effectively' },
          { text: 'New to betting', action: 'I\'m new to betting, explain how it works' },
        ],
      };
      
      return nextSteps[topic] || nextSteps['default'];
    }

    // ============================================
    // FAQ KNOWLEDGE BASE - Instant Responses
    // ============================================
    
    const FAQ_KNOWLEDGE = {
      // HOW TO PLACE BETS
      how_to_bet: {
        keywords: ['how to place a bet', 'how do i bet', 'how to bet on', 'placing a bet', 'make a bet on'],
        response: `**How to Place a Bet**

1. Choose a sport or match
2. Pick what you think will happen (team wins, goals scored, etc.)
3. Enter how much you want to bet
4. Confirm and wait for the result

Want me to find some good picks for you to bet on?`,
        nextSteps: 'how_to_bet',
      },
      
      // ACCOUNT & DEPOSITS
      how_to_deposit: {
        keywords: ['how to deposit', 'add money', 'fund account', 'deposit money', 'put money'],
        response: `**How to Deposit**

1. Go to "Deposit" in your account
2. Choose payment method (Mobile Money, Bank, Card)
3. Enter amount (min ZMW 10)
4. Confirm payment

Your money appears instantly for Mobile Money.`,
        nextSteps: 'account_help',
      },
      
      how_to_withdraw: {
        keywords: ['how to withdraw', 'cash out', 'get my money', 'withdrawal', 'take out money'],
        response: `**How to Withdraw**

1. Go to "Withdraw" in your account
2. Choose payment method
3. Enter amount to withdraw
4. Confirm - money arrives within 24 hours

Note: You may need to bet your deposit once before withdrawing.`,
        nextSteps: 'account_help',
      },
      
      // BETTING TERMINOLOGY
      what_is_odds: {
        keywords: ['what is odds', 'what are odds', 'odds mean', 'explain odds', 'how odds work'],
        response: `**What Are Odds?**

Odds show how much you can win.

Example: Odds of 2.50
- Bet ZMW 100 → Win ZMW 250 (including your stake)
- Higher odds = bigger win, but less likely

Simple rule: Low odds (1.20) = likely to happen. High odds (5.00) = unlikely but pays more.`,
        nextSteps: 'betting_term',
      },
      
      what_is_betslip: {
        keywords: ['what is betslip', 'what is a betslip', 'betslip mean', 'bet slip'],
        response: `**What is a Betslip?**

A betslip is like a shopping cart for your bets.

- Add picks you want to bet on
- See total odds and potential winnings
- Confirm all bets at once

You can bet on one pick (single) or combine multiple (accumulator).`,
        nextSteps: 'betting_term',
      },
      
      what_is_accumulator: {
        keywords: ['what is accumulator', 'what is acca', 'accumulator mean', 'parlay', 'multi bet', 'combo bet'],
        response: `**What is an Accumulator?**

An accumulator combines multiple bets into one.

- All picks must win for you to win
- Odds multiply together = bigger payout
- More picks = higher risk, higher reward

Example: 3 picks at 2.00 each = 8.00 total odds
Bet ZMW 50 → Win ZMW 400`,
        nextSteps: 'betting_term',
      },
      
      what_is_double_chance: {
        keywords: ['what is double chance', 'double chance mean', 'explain double chance', '1x mean', 'x2 mean'],
        response: `**What is Double Chance?**

Double Chance covers 2 outcomes instead of 1.

- **1X** = Home team wins OR Draw (you win either way)
- **X2** = Away team wins OR Draw
- **12** = Either team wins (no draw)

Lower payout but much safer. Good for close matches.`,
        nextSteps: 'betting_term',
      },
      
      what_is_over_under: {
        keywords: ['what is over under', 'over under mean', 'over 2.5', 'under 2.5', 'total goals'],
        response: `**What is Over/Under?**

Bet on total goals in a match.

- **Over 2.5** = 3 or more goals (you win)
- **Under 2.5** = 0, 1, or 2 goals (you win)

The ".5" means no ties - it's always clear who wins.

Over 2.5 is one of the most popular bets.`,
        nextSteps: 'betting_term',
      },
      
      what_is_btts: {
        keywords: ['what is btts', 'both teams score', 'btts mean', 'both teams to score'],
        response: `**What is Both Teams to Score (BTTS)?**

Simple: Will both teams score at least one goal?

- **BTTS Yes** = Both teams score (1-1, 2-1, 3-2, etc.)
- **BTTS No** = One or both teams don't score (1-0, 0-0, 3-0)

Good for matches between attacking teams.`,
        nextSteps: 'betting_term',
      },
      
      what_is_handicap: {
        keywords: ['what is handicap', 'handicap mean', 'asian handicap', 'handicap betting', '-1 handicap', '+1 handicap'],
        response: `**What is Handicap Betting?**

Handicap gives one team a virtual advantage or disadvantage.

Example: Liverpool -1 Handicap
- Liverpool must win by 2+ goals for your bet to win
- If Liverpool wins 2-0, you win. If 1-0, you lose.

Used when one team is much stronger than the other.`,
        nextSteps: 'betting_term',
      },
      
      // NAVIGATION HELP
      where_is_deposit: {
        keywords: ['where is deposit', 'find deposit', 'deposit button', 'where to deposit'],
        response: `**Finding Deposit**

1. Tap the menu icon (3 lines) or your profile
2. Look for "Deposit" or "Wallet"
3. It's usually at the top of the menu

Can't find it? Try the "Account" or "My Account" section.`,
        nextSteps: 'account_help',
      },
      
      where_is_betslip: {
        keywords: ['where is betslip', 'find betslip', 'my bets', 'where are my bets', 'see my bets'],
        response: `**Finding Your Betslip**

- Look for a ticket icon at the bottom of the screen
- Or tap "Betslip" / "My Bets" in the menu
- Number badge shows how many picks you've added

Your pending and settled bets are usually in "My Bets" or "Bet History".`,
        nextSteps: 'account_help',
      },
      
      where_is_bonus: {
        keywords: ['where is bonus', 'find bonus', 'my bonus', 'bonus section', 'claim bonus'],
        response: `**Finding Your Bonus**

1. Go to "Promotions" or "Bonuses" in the menu
2. Or check "My Account" → "Bonus Balance"
3. Active bonuses show in your wallet

Bonuses usually have conditions - check the terms before using.`,
        nextSteps: 'account_help',
      },
      
      // FINDING CASINO GAMES
      where_find_aviator: {
        keywords: ['find aviator', 'where aviator', 'where is aviator', 'aviator on bwanabet', 'open aviator', 'locate aviator'],
        response: `**Finding Aviator on Bwanabet**

1. Tap "Casino" in the main menu
2. Look for "Crash Games" or "Instant Games" section
3. Aviator is usually featured at the top - look for the red plane icon

**Can't find it?** Try the search bar and type "Aviator"

Ready to win? Cash out at 1.5x-2x for consistent profits!`,
        nextSteps: 'casino_game',
      },
      
      where_find_blackjack: {
        keywords: ['find blackjack', 'where blackjack', 'where is blackjack', 'blackjack on bwanabet', 'open blackjack', 'locate blackjack'],
        response: `**Finding Blackjack on Bwanabet**

1. Tap "Casino" in the main menu
2. Go to "Table Games" or "Live Casino" section
3. Look for Blackjack - multiple versions available

**Types available:**
- Classic Blackjack (play against computer)
- Live Blackjack (real dealer via video)

**Tip:** Live Blackjack has the best atmosphere!`,
        nextSteps: 'casino_game',
      },
      
      where_find_roulette: {
        keywords: ['find roulette', 'where roulette', 'where is roulette', 'roulette on bwanabet', 'open roulette', 'locate roulette'],
        response: `**Finding Roulette on Bwanabet**

1. Tap "Casino" in the main menu
2. Go to "Table Games" or "Live Casino" section
3. Look for Roulette - European Roulette has best odds!

**Types available:**
- European Roulette (single zero - better odds)
- Lightning Roulette (multipliers up to 500x)
- Live Roulette (real dealer via video)

**Tip:** Always pick European over American roulette!`,
        nextSteps: 'casino_game',
      },
      
      where_find_slots: {
        keywords: ['find slots', 'where slots', 'where is slots', 'slots on bwanabet', 'open slots', 'locate slots'],
        response: `**Finding Slots on Bwanabet**

1. Tap "Casino" in the main menu
2. Go to "Slots" section - it's usually the biggest section
3. Popular slots appear first, or use search

**Hot Slots Right Now:**
- Sweet Bonanza
- Gates of Olympus
- Book of Dead
- Starburst

**Tip:** Check the RTP (payout rate) - look for 96%+`,
        nextSteps: 'casino_game',
      },
      
      // CASINO BASICS
      how_aviator_works: {
        keywords: ['how aviator', 'aviator work', 'play aviator', 'aviator game'],
        response: `**How Aviator Works**

A plane takes off and a multiplier increases (1.00x → 2.00x → 5.00x...).

**How to Win:**
1. Place your bet before takeoff
2. Cash out BEFORE the plane flies away
3. The longer you wait, the higher the multiplier
4. But if the plane flies away before you cash out, you lose

**Best Strategy:** Cash out at 1.5x-2.0x for consistent wins.`,
        nextSteps: 'casino_game',
      },
      
      how_blackjack_works: {
        keywords: ['how blackjack', 'blackjack work', 'play blackjack', 'blackjack rules'],
        response: `**How Blackjack Works**

Goal: Get cards totaling closer to 21 than the dealer, without going over.

**Card Values:**
- Number cards = face value
- Face cards (J, Q, K) = 10
- Ace = 1 or 11

**Actions:**
- Hit = take another card
- Stand = keep your cards
- Double = double bet, take one card

**Best Strategy:** Stand on 17+, hit on 11 or less.`,
        nextSteps: 'casino_game',
      },
      
      how_roulette_works: {
        keywords: ['how roulette', 'roulette work', 'play roulette', 'roulette rules'],
        response: `**How Roulette Works**

A ball spins around a wheel with numbered slots (0-36).

**Bet Types:**
- Red/Black = 2x payout (almost 50% chance)
- Odd/Even = 2x payout
- Single number = 36x payout (low chance)

**Best Strategy:** Stick to Red/Black or Odd/Even for safer play. Avoid single numbers unless feeling lucky.`,
        nextSteps: 'casino_game',
      },
      
      // RESPONSIBLE GAMBLING
      responsible_gambling: {
        keywords: ['gambling problem', 'losing too much', 'addicted', 'stop gambling', 'gambling help', 'set limits'],
        response: `**Responsible Gambling**

Gambling should be fun, not stressful.

**Warning Signs:**
- Betting more than you can afford
- Chasing losses
- Gambling affecting relationships or work

**Get Help:**
- Set deposit limits in your account settings
- Take a break using "Self-Exclusion"
- Support: 1-800-522-4700

It's okay to take a break. Your wellbeing comes first.`,
        nextSteps: 'default',
      },
      
      // BEGINNER START
      new_to_betting: {
        keywords: ['new to betting', 'never bet before', 'first time betting', 'im new here', "i'm new here", 'just starting out', 'dont know how to bet', "don't know how to bet", 'teach me betting', 'learn to bet', 'how does betting work'],
        response: `**Welcome! Let's Get You Started**

Betting is simple:
1. Pick something you think will happen
2. Bet money on it
3. If you're right, you win more money back

I'll help you find easy, safe bets to start with. No complicated stuff.

Ready for your first pick?`,
        nextSteps: 'how_to_bet',
      },
    };
    
    // Search FAQ knowledge base
    function searchFAQ(message) {
      const msg = message.toLowerCase();
      
      // Skip FAQ if user is requesting ACTION (actual bets/picks), not LEARNING
      const actionPhrases = [
        'show me', 'give me', 'find me', 'get me', 'help me',
        'i want', 'place a bet', 'place bet',
        'picks for', 'tips for', 'bets for',
        'safe bets', 'easy bets', 'best bets', 'good bets',
        'winning', 'hot picks', 'top picks', 'today\'s picks',
        'recommend', 'suggest'
      ];
      
      const isActionRequest = actionPhrases.some(phrase => msg.includes(phrase));
      if (isActionRequest) {
        // Still allow FAQ for explicit "how to" or "what is" questions
        const isLearningQuestion = (msg.includes('how to') || msg.includes('how do i') || msg.includes('what is') || msg.includes('what are') || msg.includes('explain')) && !msg.includes('pick') && !msg.includes('bet for');
        if (!isLearningQuestion) {
          return null; // Skip FAQ, let AI handle the request
        }
      }
      
      for (const [key, faq] of Object.entries(FAQ_KNOWLEDGE)) {
        if (faq.keywords.some(keyword => msg.includes(keyword))) {
          return {
            response: faq.response,
            nextSteps: faq.nextSteps,
            matched: key,
          };
        }
      }
      return null;
    }

    // Cache helper functions
    function getCachedData(key) {
      const cached = apiCache.get(key);
      if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
        console.log(` Cache hit: ${key}`);
        return cached.data;
      }
      return null;
    }

    function setCachedData(key, data) {
      apiCache.set(key, { data, timestamp: Date.now() });
      // Clean old cache entries (keep max 50)
      if (apiCache.size > 50) {
        const oldestKey = apiCache.keys().next().value;
        apiCache.delete(oldestKey);
      }
    }

    // Retry helper for API calls
    async function fetchWithRetry(url, options = {}, maxRetries = 3) {
      for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
          const response = await fetch(url, options);
          if (response.ok) return response;
          if (response.status >= 500 && attempt < maxRetries) {
            console.log(` Retry ${attempt}/${maxRetries} for ${url}`);
            await new Promise(r => setTimeout(r, 1000 * attempt));
            continue;
          }
          return response; // Return non-ok response for caller to handle
        } catch (error) {
          if (attempt === maxRetries) throw error;
          console.log(` Network error, retry ${attempt}/${maxRetries}`);
          await new Promise(r => setTimeout(r, 1000 * attempt));
        }
      }
    }

    // Truncate large results for Claude API
    function truncateForClaude(result, maxItems = 10) {
      if (result.allGames && result.allGames.length > maxItems) {
        const total = result.allGames.length;
        result.allGames = result.allGames.slice(0, maxItems);
        result.liveGames = result.liveGames?.slice(0, 5) || [];
        result.upcomingGames = result.upcomingGames?.slice(0, maxItems) || [];
        result.completedGames = result.completedGames?.slice(0, 3) || [];
        result._truncated = true;
        result._note = `Showing ${maxItems} of ${total} games. Ask for more details if needed.`;
      }
      if (result.teams && result.teams.length > 20) {
        result.teams = result.teams.slice(0, 20);
        result._truncated = true;
      }
      return result;
    }

    // Check if user is online
    function isOnline() {
      return navigator.onLine;
    }

    // Initialize Supabase connection
    async function initSupabase() {
      if (SUPABASE_CONFIG.enabled && SUPABASE_CONFIG.url && SUPABASE_CONFIG.anonKey) {
        try {
          supabaseClient = window.supabase.createClient(SUPABASE_CONFIG.url, SUPABASE_CONFIG.anonKey);
          console.log(' Supabase client created');
          
          // Try to get or create test player
          await ensureTestPlayer();
          return true;
        } catch (e) {
          console.error(' Supabase connection failed:', e);
          console.log(' Falling back to localStorage');
          supabaseClient = null;
        }
      } else {
        console.log(' Supabase not configured - using localStorage');
      }
      return false;
    }

    // Ensure we have a test player in Supabase
    async function ensureTestPlayer() {
      if (!supabaseClient) return;
      
      // Check for existing player in localStorage
      const savedPlayerId = localStorage.getItem('betassist_player_id');
      
      if (savedPlayerId) {
        // Verify player exists in Supabase
        try {
          const { data, error } = await supabaseClient
            .from('players')
            .select('id')
            .eq('id', savedPlayerId)
            .single();
          
          if (data && !error) {
            currentPlayerId = savedPlayerId;
            console.log(' Loaded existing player:', currentPlayerId);
            return;
          }
        } catch (e) {
          console.log('Could not verify player, will create new one');
        }
      }
      
      // Create new player using RPC function
      try {
        const { data, error } = await supabaseClient.rpc('create_player_with_defaults', {
          p_username: 'player_' + Date.now(),
          p_country: 'Kenya',
          p_currency: 'ZMW'
        });
        
        if (error) {
          console.error(' Supabase RPC error:', error);
          console.log(' Make sure you ran the SQL schema in Supabase!');
          console.log(' Falling back to localStorage');
          supabaseClient = null;
          return;
        }
        
        if (data) {
          currentPlayerId = data;
          localStorage.setItem('betassist_player_id', data);
          console.log(' Created new player:', currentPlayerId);
        }
      } catch (e) {
        console.error(' Failed to create player:', e);
        console.log(' Falling back to localStorage');
        supabaseClient = null;
      }
    }
    
    // ============================================
    //  COMPREHENSIVE SPORTS COVERAGE - ALL LEAGUES
    // ============================================
    
    const ALL_SPORTS = {
      // ========== SOCCER / FOOTBALL - 60+ LEAGUES ==========
      soccer: {
        name: 'Soccer/Football',
        leagues: {
          // ENGLAND
          'eng.1': 'Premier League', 'eng.2': 'Championship', 'eng.3': 'League One', 'eng.4': 'League Two', 'eng.fa': 'FA Cup', 'eng.league_cup': 'EFL Cup',
          // SPAIN
          'esp.1': 'La Liga', 'esp.2': 'La Liga 2', 'esp.copa_del_rey': 'Copa del Rey',
          // GERMANY
          'ger.1': 'Bundesliga', 'ger.2': '2. Bundesliga', 'ger.dfb_pokal': 'DFB Pokal',
          // ITALY
          'ita.1': 'Serie A', 'ita.2': 'Serie B', 'ita.coppa_italia': 'Coppa Italia',
          // FRANCE
          'fra.1': 'Ligue 1', 'fra.2': 'Ligue 2', 'fra.coupe_de_france': 'Coupe de France',
          // OTHER EUROPE
          'ned.1': 'Eredivisie', 'por.1': 'Primeira Liga', 'bel.1': 'Belgian Pro League', 'sco.1': 'Scottish Premiership',
          'tur.1': 'Süper Lig', 'rus.1': 'Russian Premier League', 'ukr.1': 'Ukrainian Premier League',
          'gre.1': 'Super League Greece', 'sui.1': 'Swiss Super League', 'aut.1': 'Austrian Bundesliga',
          'den.1': 'Danish Superliga', 'nor.1': 'Eliteserien', 'swe.1': 'Allsvenskan', 'pol.1': 'Ekstraklasa',
          'cze.1': 'Czech First League', 'cro.1': 'HNL', 'ser.1': 'Serbian SuperLiga', 'rom.1': 'Liga I',
          // SOUTH AMERICA
          'arg.1': 'Liga Profesional', 'bra.1': 'Brasileirão', 'bra.2': 'Série B', 'col.1': 'Liga BetPlay',
          'chi.1': 'Primera División Chile', 'ecu.1': 'Liga Pro', 'per.1': 'Liga 1 Peru', 'uru.1': 'Primera División Uruguay',
          'par.1': 'Primera División Paraguay', 'ven.1': 'Primera División Venezuela', 'bol.1': 'División Profesional',
          // NORTH/CENTRAL AMERICA
          'usa.1': 'MLS', 'usa.nwsl': 'NWSL', 'mex.1': 'Liga MX', 'mex.2': 'Liga de Expansión',
          'crc.1': 'Primera División Costa Rica', 'hon.1': 'Liga Nacional Honduras',
          // ASIA
          'jpn.1': 'J1 League', 'jpn.2': 'J2 League', 'kor.1': 'K League 1', 'chn.1': 'Chinese Super League',
          'ind.1': 'Indian Super League', 'tha.1': 'Thai League', 'idn.1': 'Liga 1 Indonesia', 'mys.1': 'Malaysia Super League',
          'sau.1': 'Saudi Pro League', 'uae.1': 'UAE Pro League', 'qat.1': 'Qatar Stars League', 'irn.1': 'Persian Gulf Pro League',
          // OCEANIA
          'aus.1': 'A-League', 'nzl.1': 'New Zealand Football Championship',
          // AFRICA
          'rsa.1': 'PSL South Africa', 'egy.1': 'Egyptian Premier League', 'mar.1': 'Botola Pro', 
          'tun.1': 'Tunisian Ligue 1', 'nga.1': 'NPFL Nigeria', 'gha.1': 'Ghana Premier League', 'ken.1': 'Kenyan Premier League',
          // INTERNATIONAL COMPETITIONS
          'uefa.champions': 'UEFA Champions League', 'uefa.europa': 'UEFA Europa League', 'uefa.europa.conf': 'Conference League',
          'conmebol.libertadores': 'Copa Libertadores', 'conmebol.sudamericana': 'Copa Sudamericana',
          'concacaf.champions': 'CONCACAF Champions Cup', 'afc.champions': 'AFC Champions League', 'caf.champions': 'CAF Champions League',
          // INTERNATIONAL TEAMS
          'fifa.world': 'FIFA World Cup', 'fifa.worldq.uefa': 'World Cup Qual - UEFA', 'fifa.worldq.conmebol': 'World Cup Qual - CONMEBOL',
          'fifa.worldq.concacaf': 'World Cup Qual - CONCACAF', 'fifa.worldq.afc': 'World Cup Qual - AFC', 'fifa.worldq.caf': 'World Cup Qual - CAF',
          'uefa.euro': 'UEFA Euro', 'uefa.euro_qual': 'Euro Qualifiers', 'uefa.nations': 'UEFA Nations League',
          'conmebol.america': 'Copa America', 'concacaf.gold': 'CONCACAF Gold Cup', 'concacaf.nations': 'CONCACAF Nations League',
          'caf.nations': 'Africa Cup of Nations', 'afc.asian_cup': 'AFC Asian Cup',
          'fifa.friendly': 'International Friendlies', 'fifa.cwc': 'FIFA Club World Cup',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/soccer',
      },

      // ========== BASKETBALL ==========
      basketball: {
        name: 'Basketball',
        leagues: {
          'nba': 'NBA', 'wnba': 'WNBA', 'nba-g-league': 'NBA G League',
          'mens-college-basketball': 'NCAA Men\'s Basketball', 'womens-college-basketball': 'NCAA Women\'s Basketball',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/basketball',
      },

      // ========== AMERICAN FOOTBALL ==========
      football: {
        name: 'American Football',
        leagues: {
          'nfl': 'NFL', 'college-football': 'NCAA Football', 'xfl': 'XFL', 'cfl': 'CFL', 'ufl': 'UFL',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/football',
      },

      // ========== BASEBALL ==========
      baseball: {
        name: 'Baseball',
        leagues: {
          'mlb': 'MLB', 'college-baseball': 'NCAA Baseball',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/baseball',
      },

      // ========== ICE HOCKEY ==========
      hockey: {
        name: 'Ice Hockey',
        leagues: {
          'nhl': 'NHL', 'mens-college-hockey': 'NCAA Hockey',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/hockey',
      },

      // ========== TENNIS ==========
      tennis: {
        name: 'Tennis',
        leagues: {
          'atp': 'ATP Tour', 'wta': 'WTA Tour',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/tennis',
      },

      // ========== GOLF ==========
      golf: {
        name: 'Golf',
        leagues: {
          'pga': 'PGA Tour', 'lpga': 'LPGA Tour', 'euro': 'DP World Tour', 'liv': 'LIV Golf',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/golf',
      },

      // ========== MMA / COMBAT SPORTS ==========
      mma: {
        name: 'MMA',
        leagues: {
          'ufc': 'UFC', 'pfl': 'PFL', 'bellator': 'Bellator', 'one': 'ONE Championship',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/mma',
      },

      // ========== BOXING ==========
      boxing: {
        name: 'Boxing',
        leagues: {
          'boxing': 'Professional Boxing',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/boxing',
      },

      // ========== RUGBY ==========
      rugby: {
        name: 'Rugby',
        leagues: {
          'super-rugby': 'Super Rugby', 'six-nations': 'Six Nations', 'premiership': 'English Premiership',
          'top14': 'Top 14', 'urc': 'United Rugby Championship', 'mlr': 'Major League Rugby',
          'world-cup': 'Rugby World Cup',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/rugby',
      },

      // ========== CRICKET ==========
      cricket: {
        name: 'Cricket',
        leagues: {
          'ipl': 'IPL', 'bbl': 'Big Bash League', 'psl': 'Pakistan Super League', 'cpl': 'Caribbean Premier League',
          'hundred': 'The Hundred', 'sa20': 'SA20', 'ilt20': 'ILT20',
          't20-world-cup': 'T20 World Cup', 'odi-world-cup': 'ODI World Cup', 'wtc': 'World Test Championship',
          'the-ashes': 'The Ashes', 'icc-test': 'ICC Test Matches', 'icc-odi': 'ICC ODI Matches', 'icc-t20': 'ICC T20 Matches',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/cricket',
      },

      // ========== RACING ==========
      racing: {
        name: 'Racing',
        leagues: {
          'f1': 'Formula 1', 'nascar-cup': 'NASCAR Cup Series', 'nascar-xfinity': 'NASCAR Xfinity', 
          'indycar': 'IndyCar', 'motogp': 'MotoGP', 'wrc': 'World Rally Championship',
          'formula-e': 'Formula E', 'v8-supercars': 'V8 Supercars',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/racing',
      },

      // ========== ESPORTS ==========
      esports: {
        name: 'Esports',
        leagues: {
          'lol': 'League of Legends', 'csgo': 'Counter-Strike', 'dota2': 'Dota 2', 
          'valorant': 'Valorant', 'overwatch': 'Overwatch', 'rocket-league': 'Rocket League',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/esports',
      },

      // ========== AUSTRALIAN RULES ==========
      afl: {
        name: 'Australian Rules Football',
        leagues: {
          'afl': 'AFL',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/australian-football',
      },

      // ========== LACROSSE ==========
      lacrosse: {
        name: 'Lacrosse',
        leagues: {
          'pll': 'Premier Lacrosse League', 'nll': 'National Lacrosse League',
        },
        baseUrl: 'https://site.api.espn.com/apis/site/v2/sports/lacrosse',
      },
    };

    // ============================================
    // DYNAMIC URL BUILDERS
    // ============================================
    
    function buildUrl(sport, league, endpoint = 'scoreboard') {
      const sportConfig = ALL_SPORTS[sport];
      if (!sportConfig) return null;
      return `${sportConfig.baseUrl}/${league}/${endpoint}`;
    }

    function buildTeamsUrl(sport, league) {
      return buildUrl(sport, league, 'teams');
    }

    function buildStandingsUrl(sport, league) {
      const sportConfig = ALL_SPORTS[sport];
      if (!sportConfig) return null;
      return `https://site.api.espn.com/apis/v2/sports/${sport}/${league}/standings`;
    }

    // ============================================
    // LEAGUE ALIASES FOR NATURAL LANGUAGE
    // ============================================
    
    const LEAGUE_ALIASES = {
      // Soccer
      'premier league': { sport: 'soccer', league: 'eng.1' },
      'epl': { sport: 'soccer', league: 'eng.1' },
      'la liga': { sport: 'soccer', league: 'esp.1' },
      'serie a': { sport: 'soccer', league: 'ita.1' },
      'bundesliga': { sport: 'soccer', league: 'ger.1' },
      'ligue 1': { sport: 'soccer', league: 'fra.1' },
      'champions league': { sport: 'soccer', league: 'uefa.champions' },
      'europa league': { sport: 'soccer', league: 'uefa.europa' },
      'mls': { sport: 'soccer', league: 'usa.1' },
      'liga mx': { sport: 'soccer', league: 'mex.1' },
      'brasileirao': { sport: 'soccer', league: 'bra.1' },
      'j league': { sport: 'soccer', league: 'jpn.1' },
      'saudi league': { sport: 'soccer', league: 'sau.1' },
      'eredivisie': { sport: 'soccer', league: 'ned.1' },
      'world cup': { sport: 'soccer', league: 'fifa.world' },
      'copa america': { sport: 'soccer', league: 'conmebol.america' },
      'euros': { sport: 'soccer', league: 'uefa.euro' },
      'afcon': { sport: 'soccer', league: 'caf.nations' },
      // Basketball
      'nba': { sport: 'basketball', league: 'nba' },
      'wnba': { sport: 'basketball', league: 'wnba' },
      'ncaa basketball': { sport: 'basketball', league: 'mens-college-basketball' },
      'march madness': { sport: 'basketball', league: 'mens-college-basketball' },
      // Football
      'nfl': { sport: 'football', league: 'nfl' },
      'college football': { sport: 'football', league: 'college-football' },
      'ncaa football': { sport: 'football', league: 'college-football' },
      // Baseball
      'mlb': { sport: 'baseball', league: 'mlb' },
      // Hockey
      'nhl': { sport: 'hockey', league: 'nhl' },
      // Tennis
      'atp': { sport: 'tennis', league: 'atp' },
      'wta': { sport: 'tennis', league: 'wta' },
      // Golf
      'pga': { sport: 'golf', league: 'pga' },
      'lpga': { sport: 'golf', league: 'lpga' },
      // MMA
      'ufc': { sport: 'mma', league: 'ufc' },
      // Racing
      'f1': { sport: 'racing', league: 'f1' },
      'formula 1': { sport: 'racing', league: 'f1' },
      'nascar': { sport: 'racing', league: 'nascar-cup' },
      'motogp': { sport: 'racing', league: 'motogp' },
      'indycar': { sport: 'racing', league: 'indycar' },
      // Cricket
      'ipl': { sport: 'cricket', league: 'ipl' },
      'big bash': { sport: 'cricket', league: 'bbl' },
      't20 world cup': { sport: 'cricket', league: 't20-world-cup' },
      // Rugby
      'six nations': { sport: 'rugby', league: 'six-nations' },
      'super rugby': { sport: 'rugby', league: 'super-rugby' },
      // AFL
      'afl': { sport: 'afl', league: 'afl' },
    };

    // Resolve league from user input
    function resolveLeague(input) {
      const lower = input.toLowerCase().trim();
      
      // Check direct alias
      if (LEAGUE_ALIASES[lower]) {
        return LEAGUE_ALIASES[lower];
      }
      
      // Check partial matches
      for (const [alias, config] of Object.entries(LEAGUE_ALIASES)) {
        if (lower.includes(alias) || alias.includes(lower)) {
          return config;
        }
      }
      
      // Check ALL_SPORTS leagues
      for (const [sport, config] of Object.entries(ALL_SPORTS)) {
        for (const [leagueId, leagueName] of Object.entries(config.leagues)) {
          if (leagueName.toLowerCase().includes(lower) || lower.includes(leagueName.toLowerCase())) {
            return { sport, league: leagueId };
          }
        }
      }
      
      return null;
    }

    // ============================================
    //  BWANABET.COM CONFIGURATION
    // ============================================
    //  CONFIGURE YOUR BWANABET API ENDPOINTS BELOW 
    
    const BWANABET_CONFIG = {
      // Base URL for bwanabet API
      baseUrl: 'https://bwanabet.com',
      
      // API endpoints - UPDATE THESE with actual bwanabet endpoints
      endpoints: {
        // Odds endpoints
        odds: {
          soccer: '/api/odds/soccer',      // Example: Update with real endpoint
          basketball: '/api/odds/basketball',
          football: '/api/odds/football',
          tennis: '/api/odds/tennis',
          all: '/api/odds/all',
        },
        // Casino endpoints
        casino: {
          games: '/api/casino/games',
          slots: '/api/casino/slots',
          liveDealer: '/api/casino/live-dealer',
          tableGames: '/api/casino/table-games',
          jackpots: '/api/casino/jackpots',
        },
        // Live betting
        liveBetting: '/api/live/events',
      },
      
      // Authentication (if required)
      auth: {
        apiKey: '',           // Add API key if needed
        authHeader: '',       // e.g., 'Authorization' or 'X-API-Key'
      },
      
      // Request headers
      headers: {
        'Content-Type': 'application/json',
        // Add any required headers here
      },
    };

    // ============================================
    // DYNAMIC GAMES FETCHER - ANY SPORT, ANY LEAGUE
    // ============================================

    async function fetchGames(sportOrLeague, leagueId = null) {
      let sport, league;
      
      // Try to resolve from alias first
      const resolved = resolveLeague(sportOrLeague);
      if (resolved) {
        sport = resolved.sport;
        league = resolved.league;
      } else if (leagueId) {
        sport = sportOrLeague;
        league = leagueId;
      } else {
        // Try direct sport lookup with default league
        if (ALL_SPORTS[sportOrLeague]) {
          sport = sportOrLeague;
          league = Object.keys(ALL_SPORTS[sportOrLeague].leagues)[0];
        } else {
          return { 
            error: `Unknown sport/league: ${sportOrLeague}`,
            hint: 'Try "Premier League", "NBA", "La Liga", "UFC", "Champions League", etc.',
            availableSports: Object.keys(ALL_SPORTS),
          };
        }
      }

      // Check cache first
      const cacheKey = `games_${sport}_${league}`;
      const cached = getCachedData(cacheKey);
      if (cached) return cached;

      const url = buildUrl(sport, league, 'scoreboard');
      if (!url) {
        return { error: `Could not build URL for ${sport}/${league}` };
      }

      console.log(` Fetching games from: ${url}`);

      try {
        const response = await fetchWithRetry(url);
        if (!response.ok) throw new Error(`ESPN API error: ${response.status}`);
        
        const data = await response.json();
        const leagueName = ALL_SPORTS[sport]?.leagues[league] || league;
        
        // Transform ESPN data
        const games = (data.events || []).map(event => {
          const competition = event.competitions?.[0];
          const homeTeam = competition?.competitors?.find(c => c.homeAway === 'home');
          const awayTeam = competition?.competitors?.find(c => c.homeAway === 'away');
          
          return {
            id: event.id,
            name: event.name,
            shortName: event.shortName,
            status: {
              state: event.status?.type?.state,
              detail: event.status?.type?.detail,
              clock: event.status?.displayClock,
            },
            homeTeam: homeTeam ? {
              name: homeTeam.team?.displayName,
              abbreviation: homeTeam.team?.abbreviation,
              score: homeTeam.score || '0',
              logo: homeTeam.team?.logo,
            } : null,
            awayTeam: awayTeam ? {
              name: awayTeam.team?.displayName,
              abbreviation: awayTeam.team?.abbreviation,
              score: awayTeam.score || '0',
              logo: awayTeam.team?.logo,
            } : null,
            venue: competition?.venue?.fullName,
            broadcast: competition?.broadcasts?.[0]?.names?.[0],
            startTime: event.date,
          };
        });

        const liveGames = games.filter(g => g.status.state === 'in');
        const upcomingGames = games.filter(g => g.status.state === 'pre');
        const completedGames = games.filter(g => g.status.state === 'post');

        const result = {
          sport: sport,
          league: league,
          leagueName: leagueName,
          totalGames: games.length,
          liveGames,
          upcomingGames,
          completedGames,
          allGames: games,
          fetchedAt: new Date().toISOString(),
        };

        // Cache the result
        setCachedData(cacheKey, result);
        return result;

      } catch (error) {
        console.error('Fetch error:', error);
        return { error: error.message, sport, league };
      }
    }

    // Fetch all teams in a league
    async function fetchLeagueTeams(sportOrLeague, leagueId = null) {
      let sport, league;
      
      const resolved = resolveLeague(sportOrLeague);
      if (resolved) {
        sport = resolved.sport;
        league = resolved.league;
      } else if (leagueId) {
        sport = sportOrLeague;
        league = leagueId;
      } else {
        return { error: `Unknown league: ${sportOrLeague}` };
      }

      // Check cache first
      const cacheKey = `teams_${sport}_${league}`;
      const cached = getCachedData(cacheKey);
      if (cached) return cached;

      const url = buildTeamsUrl(sport, league);
      if (!url) return { error: `Could not build teams URL` };

      try {
        const response = await fetchWithRetry(url);
        if (!response.ok) throw new Error(`API error: ${response.status}`);
        
        const data = await response.json();
        const teams = (data.sports?.[0]?.leagues?.[0]?.teams || []).map(t => ({
          id: t.team.id,
          name: t.team.displayName,
          abbreviation: t.team.abbreviation,
          logo: t.team.logos?.[0]?.href,
        }));

        const result = {
          sport,
          league,
          leagueName: ALL_SPORTS[sport]?.leagues[league],
          teams,
          totalTeams: teams.length,
          fetchedAt: new Date().toISOString(),
        };

        // Cache for longer (5 min) since teams don't change often
        apiCache.set(cacheKey, { data: result, timestamp: Date.now() });
        return result;

      } catch (error) {
        return { error: error.message, sport, league };
      }
    }

    // Search for a team by name across all leagues
    async function searchTeam(teamName) {
      const searchLower = teamName.toLowerCase();
      const results = [];
      
      // Search common leagues
      const searchLeagues = [
        { sport: 'basketball', league: 'nba' },
        { sport: 'football', league: 'nfl' },
        { sport: 'baseball', league: 'mlb' },
        { sport: 'hockey', league: 'nhl' },
        { sport: 'soccer', league: 'eng.1' },
        { sport: 'soccer', league: 'esp.1' },
        { sport: 'soccer', league: 'ger.1' },
        { sport: 'soccer', league: 'ita.1' },
        { sport: 'soccer', league: 'fra.1' },
        { sport: 'soccer', league: 'usa.1' },
      ];

      for (const { sport, league } of searchLeagues) {
        try {
          const url = buildTeamsUrl(sport, league);
          const response = await fetch(url);
          if (!response.ok) continue;
          
          const data = await response.json();
          const teams = data.sports?.[0]?.leagues?.[0]?.teams || [];
          
          for (const t of teams) {
            const name = t.team.displayName?.toLowerCase() || '';
            const abbr = t.team.abbreviation?.toLowerCase() || '';
            if (name.includes(searchLower) || abbr === searchLower || searchLower.includes(name.split(' ').pop())) {
              results.push({
                id: t.team.id,
                name: t.team.displayName,
                abbreviation: t.team.abbreviation,
                sport,
                league,
                leagueName: ALL_SPORTS[sport]?.leagues[league],
                logo: t.team.logos?.[0]?.href,
              });
            }
          }
        } catch (e) {
          continue;
        }
        
        // Limit search to avoid too many requests
        if (results.length >= 5) break;
      }

      return {
        query: teamName,
        results,
        totalFound: results.length,
      };
    }

    // List all available leagues
    function listAvailableLeagues(sportFilter = null) {
      const leagues = [];
      
      for (const [sport, config] of Object.entries(ALL_SPORTS)) {
        if (sportFilter && sport !== sportFilter) continue;
        
        for (const [leagueId, leagueName] of Object.entries(config.leagues)) {
          leagues.push({
            sport,
            sportName: config.name,
            leagueId,
            leagueName,
          });
        }
      }

      return {
        totalLeagues: leagues.length,
        totalSports: sportFilter ? 1 : Object.keys(ALL_SPORTS).length,
        leagues: sportFilter ? leagues : leagues.slice(0, 50), // Limit for readability
        allSports: Object.entries(ALL_SPORTS).map(([id, c]) => ({ id, name: c.name, leagueCount: Object.keys(c.leagues).length })),
      };
    }

    // ============================================
    // STATE
    // ============================================
    
    let conversationHistory = [];
    let isProcessing = false;

    // ============================================
    //  PLAYER DATABASE SCHEMA & PROFILE SYSTEM
    // ============================================

    // Comprehensive player data model (simulates database)
    const DEFAULT_PLAYER_DATA = {
      // === BASIC PROFILE ===
      profile: {
        id: 'player_' + Date.now(),
        username: '',
        country: '',
        city: '',
        language: 'en',
        currency: 'ZMW',
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        createdAt: new Date().toISOString(),
        lastLogin: new Date().toISOString(),
        accountStatus: 'active',
      },

      // === BETTING PREFERENCES ===
      preferences: {
        favoriteSports: [],
        favoriteLeagues: [],
        favoriteTeams: [],
        preferredBetTypes: [],
        preferredOddsFormat: 'decimal',
        preferredStakeRange: { min: 100, max: 5000, average: 500 },
        riskTolerance: 'medium',
        preferredOddsRange: { min: 1.30, max: 5.00 },
        notifications: { matchReminders: true, betSuggestions: true, results: true },
      },

      // === BETTING HISTORY ===
      bettingHistory: {
        lifetime: {
          totalBets: 0,
          totalStaked: 0,
          totalWinnings: 0,
          netProfit: 0,
          winRate: 0,
          averageOdds: 0,
          averageStake: 0,
          biggestWin: 0,
          biggestLoss: 0,
          currentStreak: { type: null, count: 0 },
        },
        bySport: {},
        byBetType: {},
        byLeague: {},
        byTeam: {},
        recentBets: [],
        pendingBets: [],
      },

      // === BEHAVIORAL DATA ===
      behavior: {
        activity: {
          loginFrequency: 'new',
          sessionsThisWeek: 0,
          averageSessionDuration: 0,
          peakActivityTimes: [],
          peakActivityDays: [],
          preferredDevice: 'unknown',
        },
        browsing: {
          leagueViews: {},
          teamViews: {},
          recentSearches: [],
          viewedMatches: [],
        },
        engagement: {
          suggestionsViewed: 0,
          suggestionsAccepted: 0,
          suggestionsDismissed: 0,
        },
      },

      // === FINANCIAL DATA ===
      financial: {
        balance: { available: 0, bonus: 0, pending: 0 },
        limits: {
          dailyDeposit: { set: null, used: 0 },
          dailyLoss: { set: null, used: 0 },
          singleBetMax: null,
        },
        averageDeposit: 0,
      },

      // === RESPONSIBLE GAMBLING ===
      responsibleGambling: {
        riskScore: 1,
        riskFactors: [],
        selfControls: {
          depositLimits: false,
          lossLimits: false,
          sessionTimeLimit: null,
        },
        flags: {
          chasingLosses: false,
          increasingStakes: false,
          lateNightBetting: false,
        },
      },

      // === AI PERSONALIZATION ===
      aiPersonalization: {
        learnedPreferences: {
          profitableTeams: [],
          unprofitableTeams: [],
          profitableBetTypes: [],
          unprofitableBetTypes: [],
          profitableLeagues: [],
          optimalOddsRange: { min: 1.50, max: 3.00 },
        },
        recommendations: {
          accepted: [],
          rejected: [],
          dismissed: [],
          acceptanceRate: 0,
        },
        bestTimeToEngage: null,
        preferredMessageStyle: 'detailed',
      },
    };

    // Load player data from Supabase or localStorage
    async function loadPlayerData() {
      // If Supabase is configured and connected
      if (supabaseClient && currentPlayerId) {
        try {
          console.log(' Fetching player data from Supabase...');
          const { data, error } = await supabaseClient.rpc('get_player_ai_profile', {
            p_player_id: currentPlayerId
          });
          
          if (error) {
            console.error(' Supabase RPC error:', error);
            console.log(' The get_player_ai_profile function may not exist in your database.');
            console.log(' Falling back to localStorage');
          } else if (data) {
            console.log(' Loaded player data from Supabase');
            return transformSupabaseData(data);
          }
        } catch (e) {
          console.error(' Supabase load error:', e);
          console.log(' Falling back to localStorage');
        }
      }
      
      // Fallback to localStorage
      try {
        const saved = localStorage.getItem('betassist_player_data');
        if (saved) {
          console.log(' Loaded player data from localStorage');
          const data = JSON.parse(saved);
          return deepMerge(DEFAULT_PLAYER_DATA, data);
        }
      } catch (e) {
        console.log('Could not load player data from localStorage');
      }
      
      console.log(' Using default player data');
      return JSON.parse(JSON.stringify(DEFAULT_PLAYER_DATA));
    }

    // Transform Supabase data to match our schema
    function transformSupabaseData(supabaseData) {
      return {
        profile: {
          id: supabaseData.profile?.id || '',
          username: supabaseData.profile?.username || '',
          country: supabaseData.profile?.country || '',
          city: supabaseData.profile?.city || '',
          language: supabaseData.profile?.language || 'en',
          currency: supabaseData.profile?.currency || 'ZMW',
          timezone: supabaseData.profile?.timezone || '',
          createdAt: supabaseData.profile?.created_at || new Date().toISOString(),
          lastLogin: supabaseData.profile?.last_login || new Date().toISOString(),
          accountStatus: supabaseData.profile?.account_status || 'active',
        },
        preferences: {
          favoriteSports: supabaseData.preferences?.favorite_sports || [],
          favoriteLeagues: supabaseData.preferences?.favorite_leagues || [],
          favoriteTeams: supabaseData.preferences?.favorite_teams || [],
          preferredBetTypes: supabaseData.preferences?.preferred_bet_types || [],
          preferredOddsFormat: supabaseData.preferences?.odds_format || 'decimal',
          preferredStakeRange: {
            min: supabaseData.preferences?.preferred_stake_min || 100,
            max: supabaseData.preferences?.preferred_stake_max || 5000,
            average: supabaseData.preferences?.preferred_stake_avg || 500,
          },
          riskTolerance: supabaseData.preferences?.risk_tolerance || 'medium',
          preferredOddsRange: {
            min: supabaseData.preferences?.preferred_odds_min || 1.30,
            max: supabaseData.preferences?.preferred_odds_max || 5.00,
          },
        },
        bettingHistory: {
          lifetime: {
            totalBets: supabaseData.stats?.total_bets || 0,
            totalStaked: supabaseData.stats?.total_staked || 0,
            totalWinnings: supabaseData.stats?.total_winnings || 0,
            netProfit: supabaseData.stats?.net_profit || 0,
            winRate: supabaseData.stats?.win_rate || 0,
            averageOdds: supabaseData.stats?.average_odds || 0,
            averageStake: supabaseData.stats?.average_stake || 0,
            biggestWin: supabaseData.stats?.biggest_win || 0,
            biggestLoss: supabaseData.stats?.biggest_loss || 0,
            currentStreak: {
              type: supabaseData.stats?.current_streak_type || null,
              count: supabaseData.stats?.current_streak_count || 0,
            },
          },
          recentBets: supabaseData.recentBets || [],
          bySport: {},
          byLeague: {},
        },
        behavior: {
          activity: {
            loginFrequency: supabaseData.behavior?.login_frequency || 'new',
            sessionsThisWeek: supabaseData.behavior?.sessions_this_week || 0,
          },
          browsing: {
            leagueViews: supabaseData.behavior?.league_views || {},
            teamViews: supabaseData.behavior?.team_views || {},
            recentSearches: supabaseData.behavior?.recent_searches || [],
          },
          engagement: {
            suggestionsViewed: supabaseData.behavior?.suggestions_viewed || 0,
            suggestionsAccepted: supabaseData.behavior?.suggestions_accepted || 0,
            suggestionsDismissed: supabaseData.behavior?.suggestions_dismissed || 0,
          },
        },
        financial: {
          balance: {
            available: supabaseData.financial?.balance_available || 0,
            bonus: supabaseData.financial?.balance_bonus || 0,
            pending: supabaseData.financial?.balance_pending || 0,
          },
          limits: {
            dailyDeposit: { 
              set: supabaseData.financial?.daily_deposit_limit, 
              used: supabaseData.financial?.daily_deposit_used || 0 
            },
            dailyLoss: { 
              set: supabaseData.financial?.daily_loss_limit, 
              used: supabaseData.financial?.daily_loss_used || 0 
            },
          },
        },
        responsibleGambling: {
          riskScore: supabaseData.responsibleGambling?.risk_score || 1,
          riskFactors: supabaseData.responsibleGambling?.risk_factors || [],
          selfControls: {
            depositLimits: supabaseData.responsibleGambling?.deposit_limits_enabled || false,
            lossLimits: supabaseData.responsibleGambling?.loss_limits_enabled || false,
            sessionTimeLimit: supabaseData.responsibleGambling?.session_time_limit,
          },
          flags: {
            chasingLosses: supabaseData.responsibleGambling?.chasing_losses_flag || false,
            increasingStakes: supabaseData.responsibleGambling?.increasing_stakes_flag || false,
            lateNightBetting: supabaseData.responsibleGambling?.late_night_betting_flag || false,
          },
        },
        aiPersonalization: {
          learnedPreferences: {
            profitableTeams: supabaseData.aiData?.profitable_teams || [],
            unprofitableTeams: supabaseData.aiData?.unprofitable_teams || [],
            profitableBetTypes: supabaseData.aiData?.profitable_bet_types || [],
            unprofitableBetTypes: supabaseData.aiData?.unprofitable_bet_types || [],
            profitableLeagues: supabaseData.aiData?.profitable_leagues || [],
            optimalOddsRange: {
              min: supabaseData.aiData?.optimal_odds_min || 1.50,
              max: supabaseData.aiData?.optimal_odds_max || 3.00,
            },
          },
          recommendations: {
            accepted: supabaseData.aiData?.accepted_recommendations || [],
            rejected: supabaseData.aiData?.rejected_recommendations || [],
            dismissed: supabaseData.aiData?.dismissed_recommendations || [],
            acceptanceRate: supabaseData.aiData?.acceptance_rate || 0,
          },
        },
      };
    }

    // Save player data to Supabase or localStorage
    async function savePlayerData() {
      // If Supabase is configured
      if (supabaseClient && currentPlayerId) {
        try {
          // Update preferences
          await supabaseClient.from('player_preferences').update({
            favorite_sports: playerData.preferences.favoriteSports,
            favorite_leagues: playerData.preferences.favoriteLeagues,
            favorite_teams: playerData.preferences.favoriteTeams,
            risk_tolerance: playerData.preferences.riskTolerance,
            preferred_stake_avg: playerData.preferences.preferredStakeRange.average,
            updated_at: new Date().toISOString(),
          }).eq('player_id', currentPlayerId);
          
          // Update behavior
          await supabaseClient.from('player_behavior').update({
            league_views: playerData.behavior.browsing.leagueViews,
            team_views: playerData.behavior.browsing.teamViews,
            suggestions_viewed: playerData.behavior.engagement.suggestionsViewed,
            suggestions_accepted: playerData.behavior.engagement.suggestionsAccepted,
            suggestions_dismissed: playerData.behavior.engagement.suggestionsDismissed,
            updated_at: new Date().toISOString(),
          }).eq('player_id', currentPlayerId);
          
          // Update AI data
          await supabaseClient.from('player_ai_data').update({
            profitable_teams: playerData.aiPersonalization.learnedPreferences.profitableTeams,
            unprofitable_teams: playerData.aiPersonalization.learnedPreferences.unprofitableTeams,
            accepted_recommendations: playerData.aiPersonalization.recommendations.accepted,
            rejected_recommendations: playerData.aiPersonalization.recommendations.rejected,
            dismissed_recommendations: playerData.aiPersonalization.recommendations.dismissed,
            acceptance_rate: playerData.aiPersonalization.recommendations.acceptanceRate,
            updated_at: new Date().toISOString(),
          }).eq('player_id', currentPlayerId);
          
          console.log(' Saved to Supabase');
          return;
        } catch (e) {
          console.error('Supabase save error:', e);
        }
      }
      
      // Fallback to localStorage
      try {
        playerData.profile.lastLogin = new Date().toISOString();
        localStorage.setItem('betassist_player_data', JSON.stringify(playerData));
      } catch (e) {
        console.log('Could not save player data');
      }
    }

    // Debounced version of savePlayerData - prevents too many saves
    function debouncedSavePlayerData() {
      if (saveTimeout) clearTimeout(saveTimeout);
      saveTimeout = setTimeout(() => {
        savePlayerData();
      }, SAVE_DEBOUNCE);
    }

    // Record a bet to Supabase
    async function recordBetToSupabase(betData) {
      if (!supabaseClient || !currentPlayerId) return;
      
      try {
        await supabaseClient.from('bets').insert({
          player_id: currentPlayerId,
          sport: betData.sport,
          league: betData.league,
          league_name: betData.leagueName,
          match_name: betData.matchName,
          bet_type: betData.betType,
          selection: betData.selection,
          odds: betData.odds,
          stake: betData.stake,
          status: betData.status || 'pending',
        });
        console.log(' Bet recorded to Supabase');
      } catch (e) {
        console.error('Error recording bet:', e);
      }
    }

    // Deep merge helper
    function deepMerge(target, source) {
      const result = { ...target };
      for (const key in source) {
        if (source[key] instanceof Object && key in target) {
          result[key] = deepMerge(target[key], source[key]);
        } else {
          result[key] = source[key];
        }
      }
      return result;
    }

    // Current player data (loaded during initialization)
    let playerData = JSON.parse(JSON.stringify(DEFAULT_PLAYER_DATA));

    // ============================================
    //  PLAYER DATA TRACKING FUNCTIONS
    // ============================================

    // Track league view
    function trackLeagueView(leagueId, leagueName) {
      if (!playerData.behavior.browsing.leagueViews[leagueId]) {
        playerData.behavior.browsing.leagueViews[leagueId] = { name: leagueName, views: 0, lastViewed: null };
      }
      playerData.behavior.browsing.leagueViews[leagueId].views++;
      playerData.behavior.browsing.leagueViews[leagueId].lastViewed = new Date().toISOString();

      // Auto-add to favorites after 3 views
      if (playerData.behavior.browsing.leagueViews[leagueId].views >= 3) {
        const exists = playerData.preferences.favoriteLeagues.find(l => l.id === leagueId);
        if (!exists) {
          playerData.preferences.favoriteLeagues.push({ id: leagueId, name: leagueName, addedAt: new Date().toISOString() });
        }
      }
      debouncedSavePlayerData();
    }

    // Track team view
    function trackTeamView(teamName, leagueId) {
      const key = `${teamName}|${leagueId}`;
      if (!playerData.behavior.browsing.teamViews[key]) {
        playerData.behavior.browsing.teamViews[key] = { team: teamName, league: leagueId, views: 0, lastViewed: null };
      }
      playerData.behavior.browsing.teamViews[key].views++;
      playerData.behavior.browsing.teamViews[key].lastViewed = new Date().toISOString();

      // Auto-add to favorites after 3 views
      if (playerData.behavior.browsing.teamViews[key].views >= 3) {
        const exists = playerData.preferences.favoriteTeams.find(t => t.name === teamName);
        if (!exists) {
          playerData.preferences.favoriteTeams.push({ name: teamName, league: leagueId, addedAt: new Date().toISOString() });
        }
      }
      debouncedSavePlayerData();
    }

    // Record a bet (for history tracking)
    function recordBet(betData) {
      playerData.bettingHistory.recentBets.unshift({
        ...betData,
        id: 'bet_' + Date.now(),
        date: new Date().toISOString(),
      });
      
      // Keep only last 100 bets
      playerData.bettingHistory.recentBets = playerData.bettingHistory.recentBets.slice(0, 100);
      
      // Update lifetime stats
      const lifetime = playerData.bettingHistory.lifetime;
      lifetime.totalBets++;
      lifetime.totalStaked += betData.stake;
      
      if (betData.status === 'won') {
        lifetime.totalWinnings += betData.payout;
        lifetime.netProfit += betData.profit;
        if (betData.profit > lifetime.biggestWin) lifetime.biggestWin = betData.profit;
      } else if (betData.status === 'lost') {
        lifetime.netProfit -= betData.stake;
        if (betData.stake > lifetime.biggestLoss) lifetime.biggestLoss = betData.stake;
      }
      
      lifetime.winRate = playerData.bettingHistory.recentBets.filter(b => b.status === 'won').length / 
                         playerData.bettingHistory.recentBets.filter(b => b.status !== 'pending').length || 0;
      
      savePlayerData();
    }

    // Track suggestion interaction
    function trackSuggestionInteraction(suggestionId, action) {
      playerData.behavior.engagement.suggestionsViewed++;
      
      if (action === 'accepted') {
        playerData.behavior.engagement.suggestionsAccepted++;
        playerData.aiPersonalization.recommendations.accepted.push(suggestionId);
      } else if (action === 'rejected') {
        playerData.aiPersonalization.recommendations.rejected.push(suggestionId);
      } else if (action === 'dismissed') {
        playerData.behavior.engagement.suggestionsDismissed++;
        playerData.aiPersonalization.recommendations.dismissed.push(suggestionId);
      }
      
      // Calculate acceptance rate
      const total = playerData.behavior.engagement.suggestionsViewed;
      const accepted = playerData.behavior.engagement.suggestionsAccepted;
      playerData.aiPersonalization.recommendations.acceptanceRate = total > 0 ? accepted / total : 0;
      
      debouncedSavePlayerData();
    }

    // Update player preferences
    function updatePlayerPreferences(updates) {
      playerData.preferences = deepMerge(playerData.preferences, updates);
      debouncedSavePlayerData();
      return playerData.preferences;
    }

    // Update player profile
    function updatePlayerProfile(updates) {
      playerData.profile = { ...playerData.profile, ...updates };
      debouncedSavePlayerData();
      return playerData.profile;
    }

    // ============================================
    //  AI ANALYSIS FUNCTIONS
    // ============================================

    // Get comprehensive player summary for AI
    function getPlayerSummaryForAI() {
      const topLeagues = Object.entries(playerData.behavior.browsing.leagueViews)
        .sort((a, b) => b[1].views - a[1].views)
        .slice(0, 5)
        .map(([id, data]) => ({ id, name: data.name, views: data.views }));

      const topTeams = Object.entries(playerData.behavior.browsing.teamViews)
        .sort((a, b) => b[1].views - a[1].views)
        .slice(0, 5)
        .map(([key, data]) => ({ name: data.team, league: data.league, views: data.views }));

      return {
        // Profile
        profile: {
          username: playerData.profile.username || 'Player',
          country: playerData.profile.country,
          accountAge: playerData.profile.createdAt,
          lastLogin: playerData.profile.lastLogin,
        },
        
        // Preferences
        preferences: {
          favoriteLeagues: playerData.preferences.favoriteLeagues,
          favoriteTeams: playerData.preferences.favoriteTeams,
          favoriteSports: playerData.preferences.favoriteSports,
          riskTolerance: playerData.preferences.riskTolerance,
          preferredBetTypes: playerData.preferences.preferredBetTypes,
          preferredOddsRange: playerData.preferences.preferredOddsRange,
          preferredStake: playerData.preferences.preferredStakeRange,
        },
        
        // Betting Performance
        performance: {
          totalBets: playerData.bettingHistory.lifetime.totalBets,
          winRate: (playerData.bettingHistory.lifetime.winRate * 100).toFixed(1) + '%',
          netProfit: playerData.bettingHistory.lifetime.netProfit,
          averageStake: playerData.bettingHistory.lifetime.averageStake || playerData.preferences.preferredStakeRange.average,
          currentStreak: playerData.bettingHistory.lifetime.currentStreak,
          biggestWin: playerData.bettingHistory.lifetime.biggestWin,
        },
        
        // Learned Patterns
        patterns: {
          profitableTeams: playerData.aiPersonalization.learnedPreferences.profitableTeams,
          unprofitableTeams: playerData.aiPersonalization.learnedPreferences.unprofitableTeams,
          profitableBetTypes: playerData.aiPersonalization.learnedPreferences.profitableBetTypes,
          profitableLeagues: playerData.aiPersonalization.learnedPreferences.profitableLeagues,
          optimalOddsRange: playerData.aiPersonalization.learnedPreferences.optimalOddsRange,
        },
        
        // Behavior
        behavior: {
          mostViewedLeagues: topLeagues,
          mostViewedTeams: topTeams,
          suggestionAcceptanceRate: (playerData.aiPersonalization.recommendations.acceptanceRate * 100).toFixed(0) + '%',
          totalInteractions: Object.values(playerData.behavior.browsing.leagueViews).reduce((a, b) => a + b.views, 0),
        },
        
        // Responsible Gambling Status
        responsibleGambling: {
          riskScore: playerData.responsibleGambling.riskScore,
          hasLimits: playerData.responsibleGambling.selfControls.depositLimits || playerData.responsibleGambling.selfControls.lossLimits,
          flags: playerData.responsibleGambling.flags,
        },
        
        // Financial Context
        financial: {
          balance: playerData.financial.balance.available,
          dailyLimitRemaining: playerData.financial.limits.dailyDeposit.set 
            ? playerData.financial.limits.dailyDeposit.set - playerData.financial.limits.dailyDeposit.used 
            : 'No limit set',
        },
      };
    }

    // Check if we should show responsible gambling warning
    function checkResponsibleGamblingStatus() {
      const rg = playerData.responsibleGambling;
      const warnings = [];
      
      // Check loss limit
      if (playerData.financial.limits.dailyLoss.set) {
        const remaining = playerData.financial.limits.dailyLoss.set - playerData.financial.limits.dailyLoss.used;
        if (remaining <= 0) {
          warnings.push({ type: 'limit_reached', message: 'You have reached your daily loss limit.' });
        } else if (remaining < playerData.financial.limits.dailyLoss.set * 0.2) {
          warnings.push({ type: 'limit_close', message: `Only ${remaining} remaining of your daily loss limit.` });
        }
      }
      
      // Check for concerning patterns
      if (rg.flags.chasingLosses) {
        warnings.push({ type: 'pattern', message: 'We noticed you may be chasing losses. Consider taking a break.' });
      }
      
      if (rg.riskScore >= 7) {
        warnings.push({ type: 'risk', message: 'Please gamble responsibly. Support: 1-800-522-4700' });
      }
      
      return warnings;
    }

    // Find league name from ID
    function findLeagueName(leagueId) {
      for (const [sport, config] of Object.entries(ALL_SPORTS)) {
        if (config.leagues[leagueId]) {
          return config.leagues[leagueId];
        }
      }
      return leagueId;
    }

    // ============================================
    //  SMART RECOMMENDATIONS ENGINE
    // ============================================

    async function generateRecommendations() {
      const playerSummary = getPlayerSummaryForAI();
      const rgWarnings = checkResponsibleGamblingStatus();
      const recommendations = [];

      // Check responsible gambling first
      if (rgWarnings.some(w => w.type === 'limit_reached')) {
        return {
          playerProfile: playerSummary,
          recommendations: [],
          warning: rgWarnings[0].message,
          message: 'No suggestions available - daily limit reached. Please gamble responsibly.',
        };
      }

      // Get leagues to analyze (favorites first, then most viewed)
      let leaguesToAnalyze = playerData.preferences.favoriteLeagues.map(l => l.id);
      
      // Add most viewed leagues not already in favorites
      const topViewed = Object.entries(playerData.behavior.browsing.leagueViews)
        .sort((a, b) => b[1].views - a[1].views)
        .slice(0, 3)
        .map(([league]) => league);
      
      for (const league of topViewed) {
        if (!leaguesToAnalyze.includes(league)) {
          leaguesToAnalyze.push(league);
        }
      }

      // Default to popular leagues if no history
      if (leaguesToAnalyze.length === 0) {
        leaguesToAnalyze = ['eng.1', 'esp.1', 'nba', 'nfl'];
      }

      // Analyze each league for good betting opportunities
      for (const leagueId of leaguesToAnalyze.slice(0, 4)) {
        try {
          const resolved = resolveLeague(leagueId) || { sport: 'soccer', league: leagueId };
          const gamesData = await fetchGames(leagueId);
          
          if (gamesData.error || !gamesData.upcomingGames) continue;

          // Analyze upcoming games
          for (const game of gamesData.upcomingGames.slice(0, 5)) {
            if (!game.homeTeam || !game.awayTeam) continue;

            // Check if dismissed
            const recId = `rec_${game.id}`;
            if (playerData.aiPersonalization.recommendations.dismissed.includes(recId)) continue;

            // Get team stats for analysis
            const analysis = await analyzeMatchup(game.homeTeam.name, game.awayTeam.name, resolved.league);
            
            if (analysis && analysis.confidence !== 'Low') {
              // Check if favorite team involved
              const favoriteTeamInvolved = playerData.preferences.favoriteTeams.some(
                t => t.name === game.homeTeam.name || t.name === game.awayTeam.name
              );

              // Check if in player's profitable patterns
              const isProfitableTeam = playerData.aiPersonalization.learnedPreferences.profitableTeams.some(
                t => t.team === analysis.favorite
              );

              recommendations.push({
                id: recId,
                type: 'match_recommendation',
                league: leagueId,
                leagueName: gamesData.leagueName,
                match: {
                  home: game.homeTeam.name,
                  away: game.awayTeam.name,
                  startTime: game.startTime,
                  venue: game.venue,
                },
                analysis: analysis,
                personalization: {
                  favoriteTeamInvolved,
                  isProfitableTeam,
                  matchesRiskTolerance: checkRiskTolerance(analysis.favoriteOdds),
                  matchesOddsPreference: checkOddsPreference(parseFloat(analysis.favoriteOdds)),
                },
                reason: generateRecommendationReason(analysis, playerSummary, favoriteTeamInvolved, isProfitableTeam),
                suggestedStake: calculateSuggestedStake(analysis.confidence, parseFloat(analysis.favoriteProb)),
              });
            }
          }
        } catch (e) {
          console.log(`Could not analyze league ${leagueId}:`, e);
        }
      }

      // Sort by personalization score and confidence
      recommendations.sort((a, b) => {
        // Prioritize favorite teams
        if (a.personalization.favoriteTeamInvolved && !b.personalization.favoriteTeamInvolved) return -1;
        if (b.personalization.favoriteTeamInvolved && !a.personalization.favoriteTeamInvolved) return 1;
        
        // Then by confidence
        if (a.analysis.confidence === 'High' && b.analysis.confidence !== 'High') return -1;
        if (b.analysis.confidence === 'High' && a.analysis.confidence !== 'High') return 1;
        
        // Then by probability
        return parseFloat(b.analysis.favoriteProb) - parseFloat(a.analysis.favoriteProb);
      });

      return {
        playerProfile: playerSummary,
        recommendations: recommendations.slice(0, 10),
        warnings: rgWarnings,
        generatedAt: new Date().toISOString(),
        basedOn: leaguesToAnalyze.map(l => findLeagueName(l)),
      };
    }

    // Check if odds match player's risk tolerance
    function checkRiskTolerance(odds) {
      const decimalOdds = parseFloat(odds);
      const tolerance = playerData.preferences.riskTolerance;
      
      switch (tolerance) {
        case 'low': return decimalOdds <= 1.80;
        case 'medium': return decimalOdds >= 1.40 && decimalOdds <= 3.00;
        case 'high': return decimalOdds >= 2.00;
        default: return true;
      }
    }

    // Check if odds are in player's preferred range
    function checkOddsPreference(odds) {
      const range = playerData.preferences.preferredOddsRange;
      return odds >= range.min && odds <= range.max;
    }

    // Calculate suggested stake based on confidence and probability
    function calculateSuggestedStake(confidence, probability) {
      const baseStake = playerData.preferences.preferredStakeRange.average || 500;
      
      let multiplier = 1;
      if (confidence === 'High' && probability > 65) multiplier = 1.2;
      if (confidence === 'Low') multiplier = 0.5;
      
      const suggested = Math.round(baseStake * multiplier / 100) * 100;
      return Math.min(suggested, playerData.preferences.preferredStakeRange.max);
    }

    // Quick matchup analysis for recommendations
    async function analyzeMatchup(homeTeam, awayTeam, league) {
      try {
        // Search for teams
        const homeSearch = await searchTeam(homeTeam);
        const awaySearch = await searchTeam(awayTeam);

        if (homeSearch.totalFound === 0 || awaySearch.totalFound === 0) {
          return null;
        }

        const home = homeSearch.results[0];
        const away = awaySearch.results[0];

        // Get basic stats
        const homeUrl = buildUrl(home.sport, home.league, `teams/${home.id}`);
        const awayUrl = buildUrl(away.sport, away.league, `teams/${away.id}`);

        const [homeRes, awayRes] = await Promise.all([
          fetch(homeUrl).then(r => r.json()).catch(() => null),
          fetch(awayUrl).then(r => r.json()).catch(() => null),
        ]);

        if (!homeRes?.team || !awayRes?.team) return null;

        // Extract records
        const homeRecord = homeRes.team.record?.items?.[0];
        const awayRecord = awayRes.team.record?.items?.[0];

        const homeStats = {};
        const awayStats = {};
        (homeRecord?.stats || []).forEach(s => { homeStats[s.name] = s.value; });
        (awayRecord?.stats || []).forEach(s => { awayStats[s.name] = s.value; });

        const homeWinPct = homeStats.winPercent || 0.5;
        const awayWinPct = awayStats.winPercent || 0.5;

        // Calculate probabilities (home advantage factor)
        const homeAdvantage = 0.05;
        let homeProb = (homeWinPct + homeAdvantage) / (homeWinPct + awayWinPct + homeAdvantage);
        let awayProb = 1 - homeProb;

        // Determine favorite
        const favorite = homeProb > awayProb ? 'home' : 'away';
        const favoriteProb = Math.max(homeProb, awayProb) * 100;
        const favoriteTeam = favorite === 'home' ? homeTeam : awayTeam;
        const favoriteOdds = probabilityToDecimalOdds(Math.max(homeProb, awayProb));

        // Confidence based on data quality and probability difference
        let confidence = 'Medium';
        if (favoriteProb > 65 && homeRecord && awayRecord) confidence = 'High';
        if (favoriteProb < 55 || !homeRecord || !awayRecord) confidence = 'Low';

        return {
          homeTeam,
          awayTeam,
          homeWinPct: (homeWinPct * 100).toFixed(1) + '%',
          awayWinPct: (awayWinPct * 100).toFixed(1) + '%',
          homeProb: (homeProb * 100).toFixed(1) + '%',
          awayProb: (awayProb * 100).toFixed(1) + '%',
          favorite: favoriteTeam,
          favoriteProb: favoriteProb.toFixed(1),
          favoriteOdds,
          confidence,
          homeRecord: homeRecord?.summary || 'N/A',
          awayRecord: awayRecord?.summary || 'N/A',
        };

      } catch (e) {
        console.log('Matchup analysis error:', e);
        return null;
      }
    }

    function probabilityToDecimalOdds(prob) {
      return (1 / prob).toFixed(2);
    }

    function generateRecommendationReason(analysis, profile, favoriteTeamInvolved, isProfitableTeam) {
      const reasons = [];
      
      if (favoriteTeamInvolved) {
        reasons.push(` Your favorite team is playing!`);
      }

      if (isProfitableTeam) {
        reasons.push(` You have a good track record betting on ${analysis.favorite}`);
      }
      
      if (parseFloat(analysis.favoriteProb) > 65) {
        reasons.push(`${analysis.favorite} has a strong ${analysis.favoriteProb}% win probability`);
      }
      
      if (analysis.confidence === 'High') {
        reasons.push('High confidence based on season data');
      }

      if (analysis.homeRecord && analysis.homeRecord !== 'N/A') {
        reasons.push(`Form: ${analysis.homeTeam} (${analysis.homeRecord}) vs ${analysis.awayTeam} (${analysis.awayRecord})`);
      }

      if (reasons.length === 0) {
        reasons.push('Based on current team statistics');
      }

      return reasons.join('. ');
    }

    // Get personalized suggestions for a specific league
    async function getLeagueSuggestions(leagueInput) {
      const resolved = resolveLeague(leagueInput);
      if (!resolved) {
        return { error: `Unknown league: ${leagueInput}` };
      }

      // Track this league view
      const leagueName = ALL_SPORTS[resolved.sport]?.leagues[resolved.league] || leagueInput;
      trackLeagueView(resolved.league, leagueName);

      const gamesData = await fetchGames(leagueInput);
      if (gamesData.error) return gamesData;

      const suggestions = [];
      const rgWarnings = checkResponsibleGamblingStatus();

      // Analyze upcoming games for best opportunities
      for (const game of (gamesData.upcomingGames || []).slice(0, 8)) {
        if (!game.homeTeam || !game.awayTeam) continue;

        const analysis = await analyzeMatchup(game.homeTeam.name, game.awayTeam.name, resolved.league);
        
        if (analysis) {
          // Track team views
          trackTeamView(game.homeTeam.name, resolved.league);
          trackTeamView(game.awayTeam.name, resolved.league);

          // Check personalization factors
          const favoriteTeamInvolved = playerData.preferences.favoriteTeams.some(
            t => t.name === game.homeTeam.name || t.name === game.awayTeam.name
          );

          suggestions.push({
            match: `${game.awayTeam.name} @ ${game.homeTeam.name}`,
            startTime: game.startTime,
            venue: game.venue,
            analysis,
            suggestedBet: analysis.favorite,
            odds: analysis.favoriteOdds,
            confidence: analysis.confidence,
            winProbability: analysis.favoriteProb + '%',
            favoriteTeamInvolved,
            suggestedStake: calculateSuggestedStake(analysis.confidence, parseFloat(analysis.favoriteProb)),
          });
        }
      }

      // Sort by confidence, then favorite team, then probability
      suggestions.sort((a, b) => {
        if (a.favoriteTeamInvolved && !b.favoriteTeamInvolved) return -1;
        if (b.favoriteTeamInvolved && !a.favoriteTeamInvolved) return 1;
        if (a.confidence === 'High' && b.confidence !== 'High') return -1;
        if (b.confidence === 'High' && a.confidence !== 'High') return 1;
        return parseFloat(b.winProbability) - parseFloat(a.winProbability);
      });

      return {
        league: leagueInput,
        leagueName: gamesData.leagueName,
        totalUpcoming: gamesData.upcomingGames?.length || 0,
        suggestions: suggestions.slice(0, 6),
        playerFavorite: playerData.preferences.favoriteLeagues.some(l => l.id === resolved.league),
        warnings: rgWarnings,
        playerContext: {
          riskTolerance: playerData.preferences.riskTolerance,
          preferredStake: playerData.preferences.preferredStakeRange.average,
          favoriteTeamsInLeague: playerData.preferences.favoriteTeams.filter(t => t.league === resolved.league),
        },
        disclaimer: ' These are statistical suggestions based on team performance. Gambling involves risk - never bet more than you can afford to lose.',
      };
    }

    // ============================================
    // TEAM ANALYTICS FUNCTIONS
    // ============================================

    async function fetchTeamStats(teamName, leagueInput = null) {
      // First, search for the team
      const searchResults = await searchTeam(teamName);
      
      if (searchResults.totalFound === 0) {
        return { 
          error: `Team "${teamName}" not found`,
          hint: 'Try the full team name like "Manchester United" or "Los Angeles Lakers"',
        };
      }

      // Use first result or filter by league
      let team = searchResults.results[0];
      if (leagueInput) {
        const resolved = resolveLeague(leagueInput);
        if (resolved) {
          const match = searchResults.results.find(t => t.sport === resolved.sport && t.league === resolved.league);
          if (match) team = match;
        }
      }

      const url = buildUrl(team.sport, team.league, `teams/${team.id}`);
      
      try {
        const response = await fetchWithRetry(url);
        if (!response.ok) throw new Error(`API error: ${response.status}`);
        
        const data = await response.json();
        const teamData = data.team;
        
        // Get record and stats
        const record = teamData.record?.items?.[0];
        const stats = {};
        (record?.stats || []).forEach(s => { stats[s.name] = s.value; });

        // Calculate form from recent results if available, otherwise use season record
        const wins = stats.wins || 0;
        const losses = stats.losses || 0;
        const totalGames = wins + losses;
        const last10Wins = Math.min(wins, 10);
        const last10Losses = Math.min(losses, 10 - last10Wins);

        return {
          team: {
            name: teamData.displayName,
            abbreviation: teamData.abbreviation,
            logo: teamData.logos?.[0]?.href,
            sport: team.sport,
            league: team.league,
            leagueName: ALL_SPORTS[team.sport]?.leagues[team.league],
          },
          record: {
            overall: record?.summary || 'N/A',
            wins: wins,
            losses: losses,
            winPercentage: stats.winPercent ? (stats.winPercent * 100).toFixed(1) + '%' : (totalGames > 0 ? ((wins/totalGames)*100).toFixed(1) + '%' : 'N/A'),
            pointsFor: stats.pointsFor || stats.avgPointsFor || 'N/A',
            pointsAgainst: stats.pointsAgainst || stats.avgPointsAgainst || 'N/A',
          },
          form: {
            last10: totalGames > 0 ? `${last10Wins}-${last10Losses}` : 'N/A',
            streak: stats.streak || 'N/A',
          },
          standings: teamData.standingSummary || 'N/A',
          fetchedAt: new Date().toISOString(),
        };

      } catch (error) {
        return { error: error.message, team: teamName };
      }
    }

    async function fetchHeadToHead(team1Name, team2Name, leagueInput = null) {
      const team1Stats = await fetchTeamStats(team1Name, leagueInput);
      const team2Stats = await fetchTeamStats(team2Name, leagueInput);

      if (team1Stats.error) return { error: `Team 1: ${team1Stats.error}` };
      if (team2Stats.error) return { error: `Team 2: ${team2Stats.error}` };

      const probability = calculateMatchProbability(team1Stats, team2Stats);

      return {
        team1: {
          name: team1Stats?.team?.name || team1Name,
          record: team1Stats?.record?.overall || 'N/A',
          winPct: team1Stats?.record?.winPercentage || 'N/A',
        },
        team2: {
          name: team2Stats?.team?.name || team2Name,
          record: team2Stats?.record?.overall || 'N/A',
          winPct: team2Stats?.record?.winPercentage || 'N/A',
        },
        analysis: probability,
        fetchedAt: new Date().toISOString(),
      };
    }

    async function fetchLeagueStandings(leagueInput) {
      const resolved = resolveLeague(leagueInput);
      if (!resolved) {
        return { error: `Unknown league: ${leagueInput}` };
      }

      const url = buildStandingsUrl(resolved.sport, resolved.league);
      if (!url) return { error: `Standings not available for ${leagueInput}` };

      try {
        const response = await fetchWithRetry(url);
        if (!response.ok) throw new Error(`API error: ${response.status}`);
        
        const data = await response.json();
        const standings = [];

        // Parse standings - structure varies by sport
        const groups = data.children || [data];
        for (const group of groups) {
          const groupName = group.name || '';
          const entries = group.standings?.entries || [];
          
          for (const entry of entries) {
            const team = entry.team;
            const stats = {};
            (entry.stats || []).forEach(s => { stats[s.name] = s.value; });
            
            standings.push({
              group: groupName,
              rank: stats.playoffSeed || stats.rank || 'N/A',
              team: team.displayName,
              played: stats.gamesPlayed || stats.played || 'N/A',
              wins: stats.wins || 0,
              draws: stats.ties || stats.draws || 0,
              losses: stats.losses || 0,
              points: stats.points || 'N/A',
              winPct: stats.winPercent ? (stats.winPercent * 100).toFixed(1) + '%' : 'N/A',
              goalsFor: stats.pointsFor || stats.goalsFor || 'N/A',
              goalsAgainst: stats.pointsAgainst || stats.goalsAgainst || 'N/A',
            });
          }
        }

        return {
          league: leagueInput,
          leagueName: ALL_SPORTS[resolved.sport]?.leagues[resolved.league],
          standings: standings.slice(0, 25),
          totalTeams: standings.length,
          fetchedAt: new Date().toISOString(),
        };

      } catch (error) {
        return { error: error.message, league: leagueInput };
      }
    }

    // ============================================
    // PROBABILITY CALCULATION ENGINE
    // ============================================

    function calculateMatchProbability(team1Stats, team2Stats) {
      // Extra safety: if either stats object is null/undefined, return default values
      if (!team1Stats || !team2Stats) {
        return {
          team1Probability: '50.0%',
          team2Probability: '50.0%',
          impliedOdds: {
            team1: { american: '-100', decimal: '2.00' },
            team2: { american: '-100', decimal: '2.00' },
          },
          factors: {
            seasonRecord: { team1: 'N/A', team2: 'N/A', weight: '40%' },
            recentForm: { team1: 'N/A', team2: 'N/A', weight: '30%' },
            efficiency: { team1: 'N/A', team2: 'N/A', weight: '30%' },
          },
          confidence: 'Low',
          disclaimer: ' Insufficient data for probability calculation.',
        };
      }

      try {
        // Safely access nested properties with defaults
        const getFormLast10 = (stats) => stats?.form?.last10 || 'N/A';
        const getWinPct = (stats) => {
          const pct = stats?.record?.winPercentage;
          if (!pct || pct === 'N/A') return 0.5;
          return parseFloat(pct) / 100 || 0.5;
        };
        const getPoints = (stats, type) => {
          const val = stats?.record?.[type];
          if (!val || val === 'N/A') return 100;
          return parseFloat(val) || 100;
        };

        // Extract key metrics with safe defaults
        const t1 = {
          winPct: getWinPct(team1Stats),
          form: parseFormPercentage(getFormLast10(team1Stats)),
          ppg: getPoints(team1Stats, 'pointsFor'),
          papg: getPoints(team1Stats, 'pointsAgainst'),
        };
        
        const t2 = {
          winPct: getWinPct(team2Stats),
          form: parseFormPercentage(getFormLast10(team2Stats)),
          ppg: getPoints(team2Stats, 'pointsFor'),
          papg: getPoints(team2Stats, 'pointsAgainst'),
        };

      // Calculate various probability factors
      
      // 1. Win percentage factor (40% weight)
      const winPctFactor = t1.winPct / (t1.winPct + t2.winPct);
      
      // 2. Recent form factor (30% weight)
      const formFactor = t1.form / (t1.form + t2.form + 0.001);
      
      // 3. Offensive/Defensive efficiency (30% weight)
      const t1Efficiency = t1.ppg / (t1.papg + 0.001);
      const t2Efficiency = t2.ppg / (t2.papg + 0.001);
      const efficiencyFactor = t1Efficiency / (t1Efficiency + t2Efficiency);

      // Weighted probability
      const team1Prob = (winPctFactor * 0.4) + (formFactor * 0.3) + (efficiencyFactor * 0.3);
      const team2Prob = 1 - team1Prob;

      // Convert to odds
      const team1Odds = probabilityToAmericanOdds(team1Prob);
      const team2Odds = probabilityToAmericanOdds(team2Prob);
      const team1Decimal = (1 / team1Prob).toFixed(2);
      const team2Decimal = (1 / team2Prob).toFixed(2);

      // Confidence level based on data quality
      const confidence = calculateConfidence(team1Stats, team2Stats);

      return {
        team1Probability: (team1Prob * 100).toFixed(1) + '%',
        team2Probability: (team2Prob * 100).toFixed(1) + '%',
        impliedOdds: {
          team1: {
            american: team1Odds,
            decimal: team1Decimal,
          },
          team2: {
            american: team2Odds,
            decimal: team2Decimal,
          },
        },
        factors: {
          seasonRecord: {
            team1: team1Stats?.record?.winPercentage || 'N/A',
            team2: team2Stats?.record?.winPercentage || 'N/A',
            weight: '40%',
          },
          recentForm: {
            team1: team1Stats?.form?.last10 || 'N/A',
            team2: team2Stats?.form?.last10 || 'N/A',
            weight: '30%',
          },
          efficiency: {
            team1: `${t1.ppg.toFixed(1)} PPG / ${t1.papg.toFixed(1)} PAPG`,
            team2: `${t2.ppg.toFixed(1)} PPG / ${t2.papg.toFixed(1)} PAPG`,
            weight: '30%',
          },
        },
        confidence: confidence,
        disclaimer: ' These probabilities are estimates based on available statistics. Gambling involves risk and past performance does not guarantee future results.',
      };
      } catch (e) {
        console.error('Error in calculateMatchProbability:', e);
        return {
          team1Probability: '50.0%',
          team2Probability: '50.0%',
          impliedOdds: {
            team1: { american: '-100', decimal: '2.00' },
            team2: { american: '-100', decimal: '2.00' },
          },
          factors: {
            seasonRecord: { team1: 'N/A', team2: 'N/A', weight: '40%' },
            recentForm: { team1: 'N/A', team2: 'N/A', weight: '30%' },
            efficiency: { team1: 'N/A', team2: 'N/A', weight: '30%' },
          },
          confidence: 'Low',
          disclaimer: ' Error calculating probabilities.',
        };
      }
    }

    function parseFormPercentage(form) {
      if (!form || form === 'N/A') return 0.5;
      const parts = form.split('-');
      if (parts.length !== 2) return 0.5;
      const wins = parseInt(parts[0]) || 0;
      const total = wins + (parseInt(parts[1]) || 0);
      return total > 0 ? wins / total : 0.5;
    }

    function probabilityToAmericanOdds(prob) {
      if (prob >= 0.5) {
        const odds = Math.round(-(prob / (1 - prob)) * 100);
        return odds;
      } else {
        const odds = Math.round(((1 - prob) / prob) * 100);
        return '+' + odds;
      }
    }

    function calculateConfidence(team1Stats, team2Stats) {
      // Safety check
      if (!team1Stats || !team2Stats) return 'Low';
      
      let score = 0;
      
      try {
        // Check data availability with safe access
        if (team1Stats?.record?.winPercentage && team1Stats.record.winPercentage !== 'N/A') score += 25;
        if (team2Stats?.record?.winPercentage && team2Stats.record.winPercentage !== 'N/A') score += 25;
        if (team1Stats?.form?.last10 && team1Stats.form.last10 !== 'N/A') score += 15;
        if (team2Stats?.form?.last10 && team2Stats.form.last10 !== 'N/A') score += 15;
        if (team1Stats?.record?.pointsFor && team1Stats.record.pointsFor !== 'N/A') score += 10;
        if (team2Stats?.record?.pointsFor && team2Stats.record.pointsFor !== 'N/A') score += 10;
      } catch (e) {
        console.error('Error in calculateConfidence:', e);
        return 'Low';
      }

      if (score >= 80) return 'High';
      if (score >= 50) return 'Medium';
      return 'Low';
    }

    // Calculate payout
    function calculatePayout(odds, stake) {
      let profit;
      if (odds > 0) {
        profit = (stake * odds) / 100;
      } else {
        profit = (stake * 100) / Math.abs(odds);
      }
      
      const impliedProb = odds > 0 
        ? 100 / (odds + 100) 
        : Math.abs(odds) / (Math.abs(odds) + 100);

      return {
        odds: odds,
        stake: stake,
        profit: profit.toFixed(2),
        totalReturn: (stake + profit).toFixed(2),
        impliedProbability: (impliedProb * 100).toFixed(1) + '%',
      };
    }

    // ============================================
    // BWANABET API FUNCTIONS
    // ============================================

    async function fetchBwanabetOdds(sport = 'all') {
      const endpoint = BWANABET_CONFIG.endpoints.odds[sport] || BWANABET_CONFIG.endpoints.odds.all;
      const url = BWANABET_CONFIG.baseUrl + endpoint;
      
      console.log(` Fetching odds from bwanabet: ${url}`);
      
      try {
        const headers = { ...BWANABET_CONFIG.headers };
        
        // Add auth header if configured
        if (BWANABET_CONFIG.auth.apiKey && BWANABET_CONFIG.auth.authHeader) {
          headers[BWANABET_CONFIG.auth.authHeader] = BWANABET_CONFIG.auth.apiKey;
        }

        const response = await fetch(url, {
          method: 'GET',
          headers: headers,
          mode: 'cors', // May need to adjust based on bwanabet's CORS policy
        });

        if (!response.ok) {
          throw new Error(`Bwanabet API error: ${response.status}`);
        }

        const data = await response.json();
        
        return {
          source: 'bwanabet.com',
          sport: sport,
          data: data,
          fetchedAt: new Date().toISOString(),
        };

      } catch (error) {
        console.error('Bwanabet odds fetch error:', error);
        
        // Return mock/fallback data for demo purposes
        return {
          source: 'bwanabet.com',
          sport: sport,
          error: error.message,
          note: 'Could not fetch from bwanabet.com. Check CORS settings or API endpoint configuration.',
          // Fallback demo data
          fallbackData: {
            message: 'Configure BWANABET_CONFIG with correct API endpoints to fetch live odds.',
            exampleOdds: [
              { match: 'Team A vs Team B', homeOdds: 1.85, drawOdds: 3.40, awayOdds: 4.20 },
              { match: 'Team C vs Team D', homeOdds: 2.10, drawOdds: 3.25, awayOdds: 3.50 },
            ]
          },
          fetchedAt: new Date().toISOString(),
        };
      }
    }

    async function fetchBwanabetCasinoGames(category = 'all') {
      let endpoint;
      switch(category) {
        case 'slots': endpoint = BWANABET_CONFIG.endpoints.casino.slots; break;
        case 'live': endpoint = BWANABET_CONFIG.endpoints.casino.liveDealer; break;
        case 'table': endpoint = BWANABET_CONFIG.endpoints.casino.tableGames; break;
        case 'jackpots': endpoint = BWANABET_CONFIG.endpoints.casino.jackpots; break;
        default: endpoint = BWANABET_CONFIG.endpoints.casino.games;
      }
      
      const url = BWANABET_CONFIG.baseUrl + endpoint;
      console.log(` Fetching casino games from bwanabet: ${url}`);
      
      try {
        const headers = { ...BWANABET_CONFIG.headers };
        
        if (BWANABET_CONFIG.auth.apiKey && BWANABET_CONFIG.auth.authHeader) {
          headers[BWANABET_CONFIG.auth.authHeader] = BWANABET_CONFIG.auth.apiKey;
        }

        const response = await fetch(url, {
          method: 'GET',
          headers: headers,
          mode: 'cors',
        });

        if (!response.ok) {
          throw new Error(`Bwanabet Casino API error: ${response.status}`);
        }

        const data = await response.json();
        
        return {
          source: 'bwanabet.com',
          category: category,
          games: data,
          fetchedAt: new Date().toISOString(),
        };

      } catch (error) {
        console.error('Bwanabet casino fetch error:', error);
        
        // Return fallback casino data
        return {
          source: 'bwanabet.com',
          category: category,
          error: error.message,
          note: 'Could not fetch from bwanabet.com. Check API endpoint configuration.',
          // Fallback demo data showing what structure we expect
          fallbackData: {
            message: 'Configure BWANABET_CONFIG with correct API endpoints to fetch live casino games.',
            exampleGames: [
              { name: 'Blackjack Classic', category: 'table', rtp: '99.5%', provider: 'Evolution' },
              { name: 'European Roulette', category: 'table', rtp: '97.3%', provider: 'Pragmatic' },
              { name: 'Mega Fortune', category: 'slots', rtp: '96.6%', jackpot: true },
              { name: 'Live Baccarat', category: 'live', rtp: '98.9%', provider: 'Evolution' },
            ]
          },
          fetchedAt: new Date().toISOString(),
        };
      }
    }

    async function fetchBwanabetLiveBetting() {
      const url = BWANABET_CONFIG.baseUrl + BWANABET_CONFIG.endpoints.liveBetting;
      console.log(` Fetching live betting from bwanabet: ${url}`);
      
      try {
        const headers = { ...BWANABET_CONFIG.headers };
        
        if (BWANABET_CONFIG.auth.apiKey && BWANABET_CONFIG.auth.authHeader) {
          headers[BWANABET_CONFIG.auth.authHeader] = BWANABET_CONFIG.auth.apiKey;
        }

        const response = await fetch(url, {
          method: 'GET',
          headers: headers,
          mode: 'cors',
        });

        if (!response.ok) {
          throw new Error(`Bwanabet Live API error: ${response.status}`);
        }

        const data = await response.json();
        
        return {
          source: 'bwanabet.com',
          type: 'live_betting',
          events: data,
          fetchedAt: new Date().toISOString(),
        };

      } catch (error) {
        console.error('Bwanabet live betting fetch error:', error);
        
        return {
          source: 'bwanabet.com',
          type: 'live_betting',
          error: error.message,
          note: 'Could not fetch live betting data. Check API configuration.',
          fallbackData: {
            message: 'Configure BWANABET_CONFIG to fetch live betting events.',
          },
          fetchedAt: new Date().toISOString(),
        };
      }
    }

    // ============================================
    // TOOL DEFINITIONS FOR CLAUDE
    // ============================================

    const tools = [
      {
        name: 'get_player_profile',
        description: 'Get the current player\'s profile including their favorite leagues, teams, viewing history, and preferences. Use this to personalize recommendations.',
        input_schema: {
          type: 'object',
          properties: {},
          required: [],
        },
      },
      {
        name: 'update_player_preferences',
        description: 'Update the player\'s preferences like favorite leagues, teams, risk tolerance, etc.',
        input_schema: {
          type: 'object',
          properties: {
            favoriteLeagues: {
              type: 'array',
              items: { type: 'string' },
              description: 'List of favorite league IDs (e.g., ["eng.1", "esp.1"])',
            },
            favoriteTeams: {
              type: 'array',
              items: { type: 'object' },
              description: 'List of favorite teams [{name, league}]',
            },
            riskTolerance: {
              type: 'string',
              enum: ['low', 'medium', 'high'],
              description: 'Player\'s risk tolerance for betting suggestions',
            },
          },
          required: [],
        },
      },
      {
        name: 'get_recommendations',
        description: 'Generate personalized betting recommendations based on the player\'s favorite leagues and viewing history. Returns matches with high win probability.',
        input_schema: {
          type: 'object',
          properties: {},
          required: [],
        },
      },
      {
        name: 'get_league_suggestions',
        description: 'Get smart betting suggestions for a specific league. Analyzes upcoming matches and identifies games where one team has a statistical advantage.',
        input_schema: {
          type: 'object',
          properties: {
            league: {
              type: 'string',
              description: 'The league to get suggestions for (e.g., "Premier League", "La Liga")',
            }
          },
          required: ['league'],
        },
      },
      {
        name: 'get_games',
        description: 'Fetch live, upcoming, and completed games for ANY sport or league worldwide. Supports 100+ leagues including Premier League, La Liga, Serie A, Bundesliga, Champions League, NBA, NFL, MLB, NHL, UFC, F1, Cricket IPL, and many more.',
        input_schema: {
          type: 'object',
          properties: {
            league: {
              type: 'string',
              description: 'The league name (e.g., "Premier League", "NBA", "La Liga", "Champions League", "UFC", "F1", "IPL")',
            }
          },
          required: ['league'],
        },
      },
      {
        name: 'list_leagues',
        description: 'List all available sports and leagues. Use this when users ask what sports/leagues are available or want to browse options.',
        input_schema: {
          type: 'object',
          properties: {
            sport: {
              type: 'string',
              description: 'Optional: filter by sport (soccer, basketball, football, baseball, hockey, tennis, golf, mma, boxing, rugby, cricket, racing, esports)',
            }
          },
          required: [],
        },
      },
      {
        name: 'search_team',
        description: 'Search for a team by name across all leagues. Use this to find team information when the user mentions a team name.',
        input_schema: {
          type: 'object',
          properties: {
            team_name: {
              type: 'string',
              description: 'The team name to search for (e.g., "Manchester United", "Lakers", "Real Madrid")',
            }
          },
          required: ['team_name'],
        },
      },
      {
        name: 'get_league_teams',
        description: 'Get all teams in a specific league. Use this when users want to see all teams in a competition.',
        input_schema: {
          type: 'object',
          properties: {
            league: {
              type: 'string',
              description: 'The league name (e.g., "Premier League", "NBA", "Serie A")',
            }
          },
          required: ['league'],
        },
      },
      {
        name: 'get_team_stats',
        description: 'Fetch detailed statistics for a specific team including record, win percentage, recent form, and roster.',
        input_schema: {
          type: 'object',
          properties: {
            team_name: {
              type: 'string',
              description: 'The team name',
            },
            league: {
              type: 'string',
              description: 'Optional: specify the league if team name is ambiguous',
            }
          },
          required: ['team_name'],
        },
      },
      {
        name: 'get_head_to_head',
        description: 'Compare two teams and calculate win probabilities based on their statistics.',
        input_schema: {
          type: 'object',
          properties: {
            team1: {
              type: 'string',
              description: 'First team name',
            },
            team2: {
              type: 'string',
              description: 'Second team name',
            },
            league: {
              type: 'string',
              description: 'Optional: specify league',
            }
          },
          required: ['team1', 'team2'],
        },
      },
      {
        name: 'get_standings',
        description: 'Fetch current league standings/table with team rankings.',
        input_schema: {
          type: 'object',
          properties: {
            league: {
              type: 'string',
              description: 'The league name (e.g., "Premier League", "NBA", "La Liga")',
            }
          },
          required: ['league'],
        },
      },
      {
        name: 'get_bwanabet_odds',
        description: 'Fetch betting odds from bwanabet.com for any sport.',
        input_schema: {
          type: 'object',
          properties: {
            sport: {
              type: 'string',
              description: 'The sport to get odds for',
            }
          },
          required: ['sport'],
        },
      },
      {
        name: 'get_bwanabet_casino_games',
        description: 'Fetch casino games from bwanabet.com.',
        input_schema: {
          type: 'object',
          properties: {
            category: {
              type: 'string',
              description: 'Category: all, slots, table, live, jackpots',
            }
          },
          required: ['category'],
        },
      },
      {
        name: 'calculate_bet_payout',
        description: 'Calculate potential payout for a bet.',
        input_schema: {
          type: 'object',
          properties: {
            odds: {
              type: 'number',
              description: 'The odds (American or Decimal)',
            },
            stake: {
              type: 'number',
              description: 'Bet amount',
            },
          },
          required: ['odds', 'stake'],
        },
      },
    ];

    // Execute tool calls
    async function executeTool(toolName, toolInput) {
      console.log(` Executing tool: ${toolName}`, toolInput);
      
      let result;
      
      switch (toolName) {
        case 'get_player_profile':
          result = getPlayerSummaryForAI();
          break;
        case 'update_player_preferences':
          result = updatePlayerPreferences(toolInput);
          break;
        case 'get_recommendations':
          result = await generateRecommendations();
          break;
        case 'get_league_suggestions':
          result = await getLeagueSuggestions(toolInput.league);
          break;
        case 'get_games':
          result = await fetchGames(toolInput.league);
          break;
        case 'list_leagues':
          result = listAvailableLeagues(toolInput.sport);
          break;
        case 'search_team':
          result = await searchTeam(toolInput.team_name);
          break;
        case 'get_league_teams':
          result = await fetchLeagueTeams(toolInput.league);
          break;
        case 'get_team_stats':
          result = await fetchTeamStats(toolInput.team_name, toolInput.league);
          break;
        case 'get_head_to_head':
          result = await fetchHeadToHead(toolInput.team1, toolInput.team2, toolInput.league);
          break;
        case 'get_standings':
          result = await fetchLeagueStandings(toolInput.league);
          break;
        case 'get_bwanabet_odds':
          result = await fetchBwanabetOdds(toolInput.sport);
          break;
        case 'get_bwanabet_casino_games':
          result = await fetchBwanabetCasinoGames(toolInput.category);
          break;
        case 'calculate_bet_payout':
          result = calculatePayout(toolInput.odds, toolInput.stake);
          break;
        default:
          result = { error: `Unknown tool: ${toolName}` };
      }
      
      // Truncate large results to save tokens and improve response time
      return truncateForClaude(result);
    }

    // ============================================
    // SYSTEM PROMPT
    // ============================================

    const SYSTEM_PROMPT = `You are BetAssist, a sports betting analyst for Bwanabet.

#####################################################################
# STOP! READ THIS FIRST - FORMATTING IS MANDATORY
#####################################################################

YOU MUST USE LINE BREAKS. EVERY RESPONSE MUST BE FORMATTED VERTICALLY.

FORBIDDEN: Writing everything in one paragraph.
REQUIRED: Each match and each pick on its own line.

EXAMPLE OF WHAT YOU MUST DO:

**West Ham vs Sunderland** - 8:30 PM
- West Ham to win - 52%
- Over 2.5 Goals - 65%
- Best: Both Teams Score

**Tottenham vs Burnley** - 11:00 PM
- Burnley to win - 52%
- Under 2.5 Goals - 60%
- Best: Over 1.5 Goals

[MORE]West Ham strong at home. Tottenham struggling with injuries.[/MORE]

NEVER DO THIS (ALL IN ONE LINE):
"West Ham vs Sunderland - West Ham to win - 52% - Over 2.5 Goals - 65% - Tottenham vs Burnley - Burnley to win"

ALWAYS:
- One match header per line (bold with **)
- One pick per line (starting with -)
- Blank line between matches
- [MORE] section at end

#####################################################################

## NO EMOJIS - Plain text only

## USER MODE - BEGINNER vs PRO

Check the [USER_MODE] in the context. Adjust your language accordingly:

**BEGINNER MODE (Simple):**
- Explain like the user is 10 years old
- ONE recommendation per response
- Always explain WHY you're recommending something
- Explain betting abbreviations: "1X (Home wins or Draw)", "Over 2.5 (3 or more goals)"
- Use confidence labels: "Very Likely", "Likely", "Risky" instead of percentages
- Always include step-by-step "How to place this bet" instructions
- End every response with: "Ready to go?" (buttons added automatically)

**PRO MODE (In-Depth):**
- Use betting jargon freely
- Show multiple options with percentages
- Include detailed stats and analysis
- End with: "Ready to go?" (buttons added automatically)

## PERSONALITY & PHRASING
- Be direct and confident, not robotic
- Sound like a helpful friend who knows betting
- Never say "Hey Bwana" - just start with the information
- Never ask questions at the end - just end with "Ready to go?"

**Good phrasing:**
- "I found something good for you..."
- "This has a strong chance..."
- "Go with [team] here."
- "My pick: [team] wins this one"

**Avoid robotic phrasing:**
- "Analysis complete"
- "Data indicates"
- "Based on my calculations"

## EVERY RECOMMENDATION NEEDS:
1. The pick itself
2. WHY you're recommending it (explain reasoning)
3. How confident you are
4. How to place the bet (in beginner mode)
5. End with "Ready to go?" (buttons are added automatically - DO NOT write them)

## IMPORTANT: DO NOT WRITE QUICK ACTIONS AS TEXT
The system automatically adds clickable buttons after your response.
NEVER write things like "[Try Blackjack] [Play Aviator] [Learn more]" in your response.
Just end with "Ready to go?" and STOP. The buttons appear automatically.

BAD (don't do this):
"Ready to go? [Try Blackjack strategy] [Play Aviator safely] [Learn Baccarat]"

GOOD (do this):
"Ready to go?"

## SIMPLE LANGUAGE

Many users don't speak English well. Use simple, clear language:

**DON'T use abbreviations:**
- EPL = "Premier League"
- UCL = "Champions League"  
- BTTS = "Both Teams Score"
- RTP = "payout rate"

**ALWAYS explain betting terms in beginner mode:**
- "1X (Home team wins or draw)"
- "Over 2.5 (3 or more goals)"
- "BTTS Yes (Both teams score at least 1 goal)"
- "Double Chance (2 outcomes covered in 1 bet)"

## CURRENCY

- **ONLY use Zambian Kwacha (ZMW)** for all amounts
- Format: ZMW 500, ZMW 1,000, etc.

## PLAYER DATA ACCESS

You have access to player data via \`get_player_profile\`:
- Favorite leagues & teams
- Betting history & win rate
- Risk tolerance
- Bonuses available
- Daily limits

## BONUSES

When relevant, note available bonuses:
- "You have a bonus you can use on this."
- "Don't forget your free bet!"

## CASINO GAMES - ALWAYS PROVIDE STRATEGY

When discussing ANY casino game, ALWAYS include:
1. How the game works (1-2 sentences)
2. Best strategy to win
3. Recommended approach for beginners

Example for Aviator:
"**Aviator**
- How it works: Plane takes off, multiplier increases. Cash out before it flies away.
- Best strategy: Cash out at 1.5x-2.0x for consistent wins
- For beginners: Start with small bets, always cash out at 1.5x until comfortable

[MORE]Higher multipliers mean bigger wins but more risk. The plane can fly away at any time.[/MORE]"

## CASINO GAME LISTS - KEEP SHORT!

When user asks "show me casino games" or "what casino games" - BE BRIEF:
- Show only TOP 3-4 games
- One line per game with hook + payout
- Add bonus reminder
- Make it exciting!

EXAMPLE FORMAT:
**Hot Casino Games Right Now**

- **Aviator** - Cash out before the plane flies! (97% payout)
- **Blackjack** - Beat the dealer to 21 (99.5% payout)
- **Roulette** - Red, black, or lucky number (97.3% payout)
- **Mega Fortune** - Progressive jackpot! (96% payout)

You have a Free Bet ready to use!

[MORE]Click any game name to learn winning strategies.[/MORE]

NEVER list more than 4 games. NEVER write paragraphs. Keep it scannable!

## MATCH RECOMMENDATIONS FORMAT

For EACH match, use this EXACT format:

**[Home] vs [Away]** - [Kickoff Time]
- [Pick 1] - [X]%
- [Pick 2] - [X]%
- [Pick 3] - [X]%
- Best: [Top pick]

Then blank line, then next match.

## [MORE] SECTION - DETAILED ANALYSIS FOR ALL MATCHES

The [MORE] section is OPTIONAL but VALUABLE. It should contain comprehensive stats and analysis for EVERY match mentioned. Users can expand it if they want deeper insights.

ALWAYS include in [MORE]:
1. **For EACH match** - provide detailed breakdown:
   - Head-to-head record (last 5 meetings)
   - Home team recent form (W/D/L)
   - Away team recent form (W/D/L)
   - Goals stats (avg scored/conceded)
   - Key injuries or suspensions
   - Why you picked what you picked

2. **Strategy tips** for the recommended bets

EXAMPLE [MORE] SECTION:

[MORE]
**Real Madrid vs Benfica Analysis:**
- H2H: Real Madrid won 3, drew 1, lost 1 in last 5 meetings
- Real Madrid home form: W-W-W-D-W (13 goals scored, 3 conceded)
- Benfica away form: W-L-W-L-D (6 goals scored, 7 conceded)
- Real Madrid averaging 2.4 goals/game at home
- Key: Vinicius Jr in top form with 5 goals in last 4 games
- Why Real Madrid to Win: Strong home record + Benfica struggles away

**Barcelona vs FC Copenhagen Analysis:**
- H2H: Barcelona won 4, drew 1 in last 5 meetings
- Barcelona home form: W-W-W-W-D (16 goals scored, 2 conceded)
- Copenhagen away form: L-L-W-L-D (3 goals scored, 9 conceded)
- Barcelona averaging 3.2 goals/game at home
- Why -1.5 Handicap: Copenhagen has conceded 2+ goals in 4 of last 5 away games

**Atletico Madrid vs Bodo/Glimt Analysis:**
- H2H: First competitive meeting
- Atletico home form: W-W-D-W-W (8 goals scored, 2 conceded)
- Bodo/Glimt away form: L-W-L-L-W (5 goals scored, 8 conceded)
- Atletico averaging 0.8 goals conceded at home
- Why Clean Sheet: Atletico's defense is elite at home

**Inter Milan vs Borussia Dortmund Analysis:**
- H2H: Inter won 2, drew 2, lost 1 in last 5 meetings
- Inter home form: W-W-W-D-W (11 goals scored, 4 conceded)
- Dortmund away form: W-L-W-W-L (9 goals scored, 7 conceded)
- Both teams score in 70% of their recent games
- Why BTTS: Both have strong attacks, Dortmund leaky defense
[/MORE]

Ready to go?

This format gives users quick picks at a glance, with full detailed analysis available if they want it.

## RESPONSIBLE GAMBLING

- If player is on a losing streak, recommend caution
- If limits reached, inform them
- Never push bets
- Support line: 1-800-522-4700

##  COVERAGE

100+ leagues: Premier League, La Liga, Serie A, Bundesliga, Champions League, NBA, NFL, MLB, NHL, UFC, F1, Cricket & more!

##  SPEED - RESPOND FAST!

**IMPORTANT: Only use tools when absolutely necessary!**

Answer these WITHOUT tools (instant response):
- Strategy questions: "What's the best betting strategy?"
- Casino explanations: "How do I play blackjack?"
- General questions: "What sports do you cover?"
- Encouragement: "I lost my bet" → Be supportive
- Bonuses: "What bonuses do I have?" → Check profile memory

Only use tools for:
- Specific live game data: "What's the score of the Liverpool game?"
- Today's matches: "What games are on today?"
- Specific recommendations: "Give me Premier League picks"
- Team stats: "How is Manchester United doing?"

## FINAL REMINDER - CRITICAL!
NEVER write quick action buttons as text in your response!
BAD: "Ready to go? [Try Blackjack] [Play Aviator] [Show more]"
GOOD: "Ready to go?"
The system adds clickable buttons automatically. Just end with "Ready to go?" and stop.

Remember: Sound analytical and data-driven, always show 5 bet options, use engagement data naturally! `;

    // ============================================
    // CLAUDE API WITH TOOL CALLING
    // ============================================

    // Helper function to call Claude via Supabase proxy
    async function callClaudeProxy(messages, system, tools) {
      console.log('Calling Edge Function:', SUPABASE_CONFIG.claudeProxyUrl);
      
      try {
        const response = await fetch(SUPABASE_CONFIG.claudeProxyUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${SUPABASE_CONFIG.anonKey}`,
          },
          body: JSON.stringify({ messages, system, tools })
        });

        if (!response.ok) {
          const errorText = await response.text();
          console.error('Proxy Error Status:', response.status);
          console.error('Proxy Error Body:', errorText);
          
          if (response.status === 404) {
            throw new Error('Edge Function not found. Please create "bet-assist-key" in Supabase.');
          }
          if (response.status === 401) {
            throw new Error('Unauthorized. Check your Supabase anon key.');
          }
          if (response.status === 500) {
            throw new Error('Edge Function error. Check ANTHROPIC_API_KEY secret is set.');
          }
          
          throw new Error(`Proxy request failed: ${response.status} - ${errorText}`);
        }

        return await response.json();
      } catch (error) {
        if (error.message.includes('Failed to fetch')) {
          console.error('Network Error - Edge Function unreachable');
          console.error('URL attempted:', SUPABASE_CONFIG.claudeProxyUrl);
          throw new Error('Cannot reach Edge Function. Check: 1) Function is deployed, 2) Function name is "smart-processor", 3) JWT verification is OFF, 4) Try redeploying function');
        }
        throw error;
      }
    }

    async function callClaudeWithTools(userMessage) {
      // Get engagement context for this request
      const engagement = getEngagementContext();
      
      // Build enhanced message with engagement data (hidden from user display)
      const enhancedMessage = `${userMessage}

[ENGAGEMENT_DATA]
- ${engagement.liveBettersText}
- ${engagement.trendingText || 'No trending picks available'}
- ${engagement.bonusText || 'No active bonuses'}
- Recent win: ${engagement.recentWinText}
[/ENGAGEMENT_DATA]`;
      
      conversationHistory.push({
        role: 'user',
        content: enhancedMessage
      });

      console.log(' Sending message via Supabase proxy...');
      console.log(' Message:', userMessage);

      try {
        let data = await callClaudeProxy(conversationHistory, SYSTEM_PROMPT, tools);
        console.log(' Response received:', data.stop_reason);
        
        // Handle tool use loop
        while (data.stop_reason === 'tool_use') {
          const toolUseBlocks = data.content.filter(block => block.type === 'tool_use');
          
          // Add assistant's response (with tool calls) to history
          conversationHistory.push({
            role: 'assistant',
            content: data.content
          });

          //  SPEED: Execute ALL tools in PARALLEL instead of sequentially
          updateTypingStatus('Typing...');
          console.log(` Executing ${toolUseBlocks.length} tools in parallel...`);
          
          const toolPromises = toolUseBlocks.map(async (toolUse) => {
            const result = await executeTool(toolUse.name, toolUse.input);
            console.log(` Tool ${toolUse.name} complete`);
            return {
              type: 'tool_result',
              tool_use_id: toolUse.id,
              content: JSON.stringify(result, null, 2)
            };
          });

          // Wait for ALL tools to complete at once
          const toolResults = await Promise.all(toolPromises);

          // Add tool results to history
          conversationHistory.push({
            role: 'user',
            content: toolResults
          });

          updateTypingStatus('Typing...');

          // Continue conversation with tool results
          data = await callClaudeProxy(conversationHistory, SYSTEM_PROMPT, tools);
        }

        // Extract final text response
        const textContent = data.content
          .filter(block => block.type === 'text')
          .map(block => block.text)
          .join('\n');

        console.log('RAW AI RESPONSE:', textContent);
        console.log('HAS NEWLINES:', textContent.includes('\n'));

        // Add final response to history
        conversationHistory.push({
          role: 'assistant',
          content: textContent
        });

        // Keep history manageable
        if (conversationHistory.length > 30) {
          conversationHistory = conversationHistory.slice(-30);
        }

        return textContent;

      } catch (error) {
        console.error('Claude API error:', error);
        conversationHistory.pop(); // Remove failed message
        
        if (error.message.includes('Invalid API Key') || error.message.includes('authentication')) {
          return '**Authentication Error**\n\nBwana, API key validation failed. Verify configuration.';
        }
        
        return `**System Error**\n\nBwana, processing failed: ${error.message}`;
      }
    }

    // ============================================
    // UI FUNCTIONS
    // ============================================

    function updateTypingStatus(status) {
      document.getElementById('typingStatus').textContent = status;
    }

    function clearChat() {
      conversationHistory = [];
      document.getElementById('messages').innerHTML = '';
      addMessage(`**System Reset**\n\nBwana, chat history cleared. System ready for new analysis requests.`, false);
    }

    async function sendMessage() {
      if (isProcessing) return;
      
      // Check if online
      if (!isOnline()) {
        addMessage("Bwana, network connection lost. Verify internet connectivity and retry.", false, [
          { text: 'Retry', action: 'hi' },
        ]);
        return;
      }
      
      // Rate limiting - prevent spam
      const now = Date.now();
      if (now - lastMessageTime < MESSAGE_COOLDOWN) {
        console.log('⏳ Please wait before sending another message');
        return;
      }
      lastMessageTime = now;
      
      const input = document.getElementById('messageInput');
      const message = input.value.trim();
      
      if (!message) return;
      
      input.value = '';
      addMessage(message, true);
      
      // Check if this is a user preference choice (from onboarding flow)
      if (handleUserPreferenceChoice(message)) {
        return; // Handled by the preference flow
      }
      
      //  INSTANT RESPONSES - No API call needed for simple messages!
      const instantResult = getInstantResponse(message);
      if (instantResult) {
        console.log(' Instant response (no API call)');
        setTimeout(() => {
          addMessage(instantResult.response, false, instantResult.quickActions || []);
        }, 300); // Small delay feels natural
        return;
      }
      
      // Check session time and remind user to take breaks
      const sessionMinutes = (now - sessionStart) / 60000;
      if (sessionMinutes > 60 && !sessionWarningShown) {
        sessionWarningShown = true;
        setTimeout(() => {
          addMessage("Bwana, session duration exceeds 60 minutes. Reminder: Take regular breaks. Gamble responsibly.", false, [
            { text: 'Acknowledged', action: 'thanks' },
            { text: 'More analysis', action: 'give me tips' },
          ]);
        }, 500);
      }
      
      isProcessing = true;
      document.getElementById('sendButton').disabled = true;
      document.getElementById('typingIndicator').classList.remove('hidden');
      updateTypingStatus('Analyzing...');
      
      // Start progress tracking (shows after 2 seconds)
      const progressTracker = startProgressTimer();
      
      try {
        const response = await callClaudeWithTools(message);
        // Generate smart quick actions based on AI's response AND user's message
        const smartActions = generateSmartQuickActions(message, response);
        addMessage(response, false, smartActions);
      } catch (error) {
        console.error('Error in sendMessage:', error);
        addMessage(`**Processing Error**\n\nRequest failed: ${error.message}\n\nCheck your connection and try again.`, false, [
          { text: 'Retry', action: message },
          { text: 'Help', action: 'help' },
        ]);
      } finally {
        isProcessing = false;
        stopProgressTimer(progressTracker);
        document.getElementById('sendButton').disabled = false;
        document.getElementById('typingIndicator').classList.add('hidden');
        
        // Show 100% briefly before hiding
        setTimeout(() => {
          document.getElementById('progressContainer').classList.add('hidden');
          // Reset progress bar for next use
          const progressBar = document.getElementById('progressBar');
          if (progressBar) progressBar.style.width = '0%';
        }, 300);
        
        updateTypingStatus('');
      }
    }
    
    // ============================================
    // PROGRESS BAR - Shows after 2 seconds of processing
    // ============================================
    
    // Start progress timer - smooth infinite progress bar
    function startProgressTimer() {
      const startTime = Date.now();
      const progressBar = document.getElementById('progressBar');
      const progressContainer = document.getElementById('progressContainer');
      
      let showProgressTimeout = null;
      let updateInterval = null;
      
      // Show progress bar after 2 seconds
      showProgressTimeout = setTimeout(() => {
        progressContainer.classList.remove('hidden');
      }, 2000);
      
      // Smooth progress animation - never reaches 100% until done
      // Uses logarithmic curve: fast at start, slows down over time
      updateInterval = setInterval(() => {
        const elapsed = (Date.now() - startTime) / 1000;
        
        // Logarithmic progress: approaches but never reaches 95%
        // At 10s: ~24%, at 20s: ~43%, at 30s: ~57%, at 60s: ~81%
        const progress = 95 * (1 - Math.exp(-elapsed / 36));
        
        progressBar.style.width = `${progress}%`;
      }, 100);
      
      return { showProgressTimeout, updateInterval, startTime };
    }
    
    // Stop progress timer
    function stopProgressTimer(tracker) {
      if (tracker) {
        if (tracker.showProgressTimeout) clearTimeout(tracker.showProgressTimeout);
        if (tracker.updateInterval) clearInterval(tracker.updateInterval);
      }
      
      // Quick fill to 100% before hiding
      const progressBar = document.getElementById('progressBar');
      if (progressBar) {
        progressBar.style.width = '100%';
      }
    }

    //  INSTANT RESPONSES - Handle common messages without API calls
    // ============================================
    //  CASINO GAME STRATEGIES DATABASE
    // ============================================
    
    const CASINO_STRATEGIES = {
      aviator: {
        name: "Aviator",
        type: "Crash Game",
        description: "Watch the multiplier rise and cash out before the plane crashes!",
        howToPlay: [
          "1. Place your bet before the round starts",
          "2. Watch the plane take off - the multiplier increases as it flies",
          "3. Click 'Cash Out' anytime to collect your bet × the current multiplier",
          "4. If the plane crashes before you cash out, you lose your bet",
          "5. The crash point is random each round (could be 1.01x or 100x+)",
        ],
        strategies: [
          "**Low Risk Strategy**: Cash out early at 1.2x-1.5x. Small wins, but consistent.",
          "**Medium Risk**: Target 2x-3x multiplier. Good balance of risk/reward.",
          "**Auto Cash-Out**: Set automatic cash-out at your target to remove emotion.",
          "**Two Bets Strategy**: Place 2 bets - cash out one early (1.5x), let the other ride.",
          "**Martingale**: Double bet after loss, return to base after win.  Risky!",
        ],
        tips: [
          "Watch the game history - but remember each round is independent!",
          "Set a budget BEFORE you start and stick to it",
          "Don't chase losses - the plane doesn't care about your previous bets",
          "Use auto cash-out to avoid panic decisions",
        ],
        rtp: "97%",
      },
      
      blackjack: {
        name: "Blackjack",
        type: "Card Game",
        description: "Beat the dealer by getting closer to 21 without going over.",
        howToPlay: [
          "1. Place your bet",
          "2. You and dealer each get 2 cards (one dealer card face down)",
          "3. Card values: Number cards = face value, J/Q/K = 10, Ace = 1 or 11",
          "4. Choose: Hit (get another card), Stand (keep your hand), Double (double bet, get one card), Split (if you have a pair)",
          "5. Try to get closer to 21 than the dealer without going over (bust)",
          "6. Dealer must hit on 16 or less, stand on 17+",
          "7. Blackjack (Ace + 10-value card) pays 3:2",
        ],
        strategies: [
          "**Basic Strategy** (memorize this!):",
          "• Always split Aces and 8s",
          "• Never split 10s or 5s", 
          "• Double down on 11 (unless dealer shows Ace)",
          "• Double down on 10 if dealer shows 2-9",
          "• Stand on 17+ always",
          "• Hit on soft 17 (Ace + 6)",
          "• Stand on 12-16 if dealer shows 2-6, otherwise hit",
        ],
        tips: [
          "Dealer must hit on 16, stand on 17 - use this!",
          "Insurance is almost always a bad bet - skip it",
          "Don't take 'even money' on blackjack",
          "Card counting doesn't work online (shuffled each hand)",
        ],
        rtp: "99.5% with perfect strategy",
      },
      
      roulette: {
        name: "Roulette", 
        type: "Table Game",
        description: "Bet on where the ball will land on the spinning wheel.",
        howToPlay: [
          "1. Place chips on the betting table before the spin",
          "2. Bet types: Single number (35:1), Red/Black (1:1), Odd/Even (1:1), Dozens (2:1), Columns (2:1)",
          "3. The wheel spins and ball lands on a number",
          "4. If you bet on that number or group, you win!",
          "5. European wheel has 0-36, American has 0, 00, and 1-36",
        ],
        strategies: [
          "**Martingale**: Double bet after each loss.  Can hit table limits fast!",
          "**Reverse Martingale**: Double after wins, reset after loss.",
          "**D'Alembert**: Increase bet by 1 after loss, decrease by 1 after win.",
          "**James Bond**: Bet 70% on 19-36, 25% on 13-18, 5% on 0.",
          "**Column Betting**: Bet on 2 columns for 64% coverage.",
        ],
        tips: [
          "European Roulette (single 0) has better odds than American (double 00)",
          "Outside bets (red/black, odd/even) have ~48% win chance",
          "Inside bets pay more but hit less often",
          "The wheel has no memory - each spin is independent!",
        ],
        rtp: "European: 97.3% | American: 94.7%",
      },
      
      slots: {
        name: "Slots",
        type: "Video Slots",
        description: "Spin the reels and match symbols to win!",
        howToPlay: [
          "1. Choose your bet amount and number of paylines",
          "2. Click Spin to start the reels",
          "3. Matching symbols on paylines = win! Check paytable for values",
          "4. Special symbols: Wild (substitutes for others), Scatter (triggers bonus)",
          "5. Bonus features: Free Spins, Multipliers, Pick-and-Win games",
          "6. Some slots have progressive jackpots that grow until someone wins",
        ],
        strategies: [
          "**Bankroll Management**: Set bet size to 1-2% of your bankroll",
          "**High payout Slots**: Look for games with 96%+ payout rate",
          "**Volatility Choice**: Low = frequent small wins, High = rare big wins",
          "**Max Bet for Jackpots**: Some progressives require max bet to qualify",
          "**Bonus Hunting**: Use free spins bonuses to extend playtime",
        ],
        tips: [
          "Check the paytable before playing - know the best symbols",
          "Set win/loss limits before you start",
          "Slots are pure luck - no skill involved",
          "Take breaks - it's easy to lose track of time and money",
        ],
        rtp: "Varies: 92-98% (check each game)",
      },
      
      poker: {
        name: "Poker (Casino/Video)",
        type: "Card Game",
        description: "Make the best 5-card hand to win.",
        howToPlay: [
          "1. Place your bet (Ante)",
          "2. You receive 5 cards",
          "3. Choose which cards to hold and which to discard",
          "4. Draw new cards to replace discards",
          "5. Hand rankings (highest to lowest): Royal Flush, Straight Flush, Four of a Kind, Full House, Flush, Straight, Three of a Kind, Two Pair, One Pair, High Card",
          "6. Minimum winning hand is usually Jacks or Better (pair of Jacks)",
        ],
        strategies: [
          "**Starting Hands**: Only play strong hands (pairs, high cards, suited connectors)",
          "**Position Matters**: Play tighter early, looser in late position",
          "**Jacks or Better Strategy**:",
          "• Keep any paying hand",
          "• Keep 4 to a flush or straight",
          "• Keep high pairs (J+)",
          "• Keep 3 to a royal flush",
        ],
        tips: [
          "Video Poker has some of the best odds in the casino",
          "Always bet max coins for the royal flush bonus",
          "Learn one game well before trying others",
          "Jacks or Better is the best game for beginners",
        ],
        rtp: "Up to 99.5% with perfect play",
      },
      
      baccarat: {
        name: "Baccarat",
        type: "Card Game", 
        description: "Bet on Player, Banker, or Tie - closest to 9 wins.",
        howToPlay: [
          "1. Bet on Player, Banker, or Tie before cards are dealt",
          "2. Player and Banker each receive 2 cards",
          "3. Card values: A=1, 2-9=face value, 10/J/Q/K=0",
          "4. Add cards together, only the last digit counts (15 = 5, 20 = 0)",
          "5. Third card may be drawn based on rules (automatic)",
          "6. Hand closest to 9 wins. Banker bet wins pay 0.95:1 (5% commission)",
        ],
        strategies: [
          "**Always bet Banker**: 1.06% house edge (best bet in the game!)",
          "**Never bet Tie**: 14.4% house edge - terrible odds",
          "**Flat Betting**: Same bet size every hand",
          "**1-3-2-4 System**: Bet 1, 3, 2, 4 units. Reset after loss or completing sequence.",
        ],
        tips: [
          "Banker bet wins ~51% of the time (that's why there's commission)",
          "No skill involved - it's pure luck",
          "Scorecards/patterns are meaningless - each hand is independent",
          "One of the simplest and best-odds casino games",
        ],
        rtp: "Banker: 98.94% | Player: 98.76% | Tie: 85.6%",
      },
      
      crash: {
        name: "Crash Games (General)",
        type: "Crash Game",
        description: "Multiplier rises until it crashes - cash out in time!",
        howToPlay: [
          "1. Place bet before round starts",
          "2. Multiplier starts at 1.00x and increases",
          "3. Cash out anytime to win bet × current multiplier",
          "4. If you don't cash out before crash, you lose",
          "5. Crash point is random and different each round",
        ],
        strategies: [
          "**Conservative**: Auto cash-out at 1.2x-1.5x for steady small wins",
          "**Balanced**: Target 2x, accept some losses for bigger wins",
          "**Aggressive**: Go for 5x+ but expect many losses",
          "**Split Strategy**: Two bets - one safe (1.5x), one risky (5x+)",
        ],
        tips: [
          "The crash point is random - patterns don't predict future rounds",
          "Set strict loss limits before playing",
          "Auto cash-out removes emotional decisions",
          "Don't chase losses with bigger bets",
        ],
        rtp: "Usually 96-97%",
      },
      
      plinko: {
        name: "Plinko",
        type: "Instant Game",
        description: "Drop a ball and watch it bounce down to win multipliers!",
        howToPlay: [
          "1. Choose your bet amount",
          "2. Select risk level: Low, Medium, or High",
          "3. Choose number of rows (more rows = more variance)",
          "4. Drop the ball from the top",
          "5. Ball bounces off pegs randomly and lands in a multiplier slot",
          "6. You win your bet × the multiplier where ball lands",
        ],
        strategies: [
          "**Low Risk**: Smaller multipliers but more consistent wins",
          "**High Risk**: Big multipliers possible but more losses",
          "**Multi-drop**: Drop multiple balls to average out variance",
          "**Bankroll Split**: Use smaller bets on high risk for big win potential",
        ],
        tips: [
          "Each drop is completely random - no patterns",
          "High risk mode can have 1000x+ multipliers but also 0.2x",
          "Low risk is best for steady play",
          "Set a loss limit before you start",
        ],
        rtp: "97-99% depending on settings",
      },
      
      spaceman: {
        name: "Spaceman",
        type: "Crash Game",
        description: "Similar to Aviator - astronaut flies up, cash out before he disappears!",
        howToPlay: [
          "1. Place bet before round starts",
          "2. Spaceman launches and multiplier grows",
          "3. Click Cash Out to collect bet × current multiplier",
          "4. If spaceman disappears before you cash out, you lose",
          "5. Can place 2 bets per round for different strategies",
        ],
        strategies: [
          "**Same as Aviator**: Early cash-out (1.5x) or risky (3x+)",
          "**Half-Half**: Cash out one bet early, let other ride",
          "**Auto Mode**: Set auto cash-out to remove emotion",
          "**Base Bet Strategy**: Keep same bet size, don't chase losses",
        ],
        tips: [
          "Works exactly like Aviator - same strategies apply",
          "Each round is independent - no patterns",
          "Use auto cash-out for consistency",
          "Never bet more than you can afford to lose",
        ],
        rtp: "96-97%",
      },
      
      crazy_time: {
        name: "Crazy Time",
        type: "Live Game Show",
        description: "Spin the big wheel for multipliers and exciting bonus games!",
        howToPlay: [
          "1. Bet on segments: Numbers (1, 2, 5, 10) or Bonus Games (Coin Flip, Pachinko, Cash Hunt, Crazy Time)",
          "2. Host spins the big wheel",
          "3. If wheel lands on your bet, you win! Numbers pay that amount (bet on 5 = win 5x)",
          "4. Bonus games have big multiplier potential",
          "5. Top Slot can add random multipliers to any segment before spin",
        ],
        strategies: [
          "**Safe Play**: Bet on 1 (most common) for frequent small wins",
          "**Balanced**: Cover 1, 2, and one bonus game",
          "**Bonus Hunter**: Focus bets on bonus games for big win potential",
          "**Coverage**: Spread bets across multiple segments",
        ],
        tips: [
          "Number 1 appears most often on the wheel",
          "Bonus games are rare but can pay huge",
          "Crazy Time bonus has the biggest potential multipliers",
          "Watch the Top Slot - multipliers can make any segment valuable",
        ],
        rtp: "Around 95-96%",
      },
      
      lightning_roulette: {
        name: "Lightning Roulette",
        type: "Live Casino",
        description: "Roulette with random lightning multipliers up to 500x!",
        howToPlay: [
          "1. Place bets like regular roulette",
          "2. Before each spin, 1-5 numbers get random Lightning multipliers (50x-500x)",
          "3. Spin happens normally",
          "4. If you bet straight on a Lightning number and it hits, you win multiplier × your bet",
          "5. Regular bets pay standard roulette odds (but straight bets pay 30:1 instead of 35:1)",
        ],
        strategies: [
          "**Chase Lightning**: Bet small on multiple straight-up numbers hoping for lightning hit",
          "**Outside + Straight**: Cover outside bets for consistency, add straight-up for lightning chance",
          "**Numbers Only**: Focus on straight-up bets to maximize lightning potential",
          "**Safe Play**: Stick to outside bets (red/black) - lightning doesn't affect these",
        ],
        tips: [
          "Straight-up bets pay less (30:1 vs 35:1) without lightning",
          "Lightning multipliers only apply to straight-up number bets",
          "Outside bets are not affected by lightning - same as regular roulette",
          "Big wins require hitting a lightning number you bet on",
        ],
        rtp: "Around 97.3%",
      },
      
      sweet_bonanza: {
        name: "Sweet Bonanza",
        type: "Video Slot",
        description: "Colorful candy slot with tumble feature and multipliers!",
        howToPlay: [
          "1. Set your bet amount",
          "2. Spin the 6x5 reel grid",
          "3. Match 8+ identical symbols anywhere to win (no paylines needed)",
          "4. Winning symbols disappear and new ones tumble down (free re-spins!)",
          "5. Tumbles continue until no new wins",
          "6. Scatter symbols (lollipops) trigger Free Spins bonus",
          "7. In Free Spins, bomb multipliers appear and add up!",
        ],
        strategies: [
          "**Buy Bonus**: If available, buying free spins guarantees the bonus round",
          "**Ante Bet**: 25% extra bet doubles scatter chances",
          "**Base Game Grind**: Play normally and wait for natural bonus triggers",
          "**Low Stakes Long Play**: Smaller bets, more spins to hit bonus",
        ],
        tips: [
          "The bonus round is where big wins happen",
          "Multipliers in bonus can stack up to huge amounts",
          "Tumble feature can chain multiple wins from one spin",
          "High volatility - expect dry spells between big wins",
        ],
        rtp: "96.51%",
      },
      
      gates_of_olympus: {
        name: "Gates of Olympus",
        type: "Video Slot",
        description: "Zeus-themed slot with multipliers and tumbling reels!",
        howToPlay: [
          "1. Set your bet",
          "2. Spin the 6x5 grid",
          "3. Match 8+ same symbols anywhere to win",
          "4. Wins tumble away, new symbols fall down",
          "5. Random multipliers (2x-500x) can appear and multiply your wins",
          "6. 4+ Scatter symbols trigger 15 Free Spins",
          "7. In Free Spins, multipliers accumulate for the entire bonus!",
        ],
        strategies: [
          "**Buy Bonus**: Skip to free spins (costs 100x bet)",
          "**Ante Bet**: Extra 25% increases scatter frequency",
          "**Regular Play**: Standard spins waiting for natural triggers",
          "**Quick Spins**: More spins = more chances at bonus",
        ],
        tips: [
          "Free Spins is where the big money is",
          "Multipliers in bonus ADD together and apply to all wins",
          "Can retrigger more free spins during bonus",
          "Very high volatility - prepare for swings",
        ],
        rtp: "96.50%",
      },
      
      mega_moolah: {
        name: "Mega Moolah",
        type: "Progressive Jackpot Slot",
        description: "Famous progressive jackpot slot with life-changing wins!",
        howToPlay: [
          "1. Set bet (higher bets = better jackpot chances)",
          "2. Spin the 5x3 African safari themed reels",
          "3. Match symbols on 25 paylines to win",
          "4. Wild Lion substitutes and doubles wins",
          "5. 3+ Scatter Monkeys trigger 15 Free Spins with 3x multiplier",
          "6. Random Jackpot Wheel can trigger anytime!",
          "7. Spin the wheel for Mini, Minor, Major, or MEGA jackpot",
        ],
        strategies: [
          "**Max Bet**: Higher bets improve jackpot trigger chances",
          "**Jackpot Focus**: Play specifically for jackpot chance, not base game",
          "**Budget Play**: Set strict limits - jackpot is rare",
          "**Timing**: Some believe playing when jackpot is high helps (unproven)",
        ],
        tips: [
          "MEGA jackpot starts at 1 million and grows",
          "Jackpot wheel is randomly triggered - can happen anytime",
          "Lower payout rate than regular slots due to jackpot contribution",
          "Play for fun, don't expect to hit the big one",
        ],
        rtp: "88.12% (low due to jackpot contribution)",
      },
      
      live_dealer: {
        name: "Live Dealer Games",
        type: "Live Casino",
        description: "Real dealers streaming in real-time!",
        howToPlay: [
          "1. Choose your live game (Blackjack, Roulette, Baccarat, etc.)",
          "2. Join a table with available seats",
          "3. Place bets during betting time",
          "4. Watch the real dealer manage the game via video stream",
          "5. Game plays out same as regular casino version",
          "6. Chat with dealer and other players if you want",
        ],
        strategies: [
          "Use the same strategies as regular table games",
          "**Live Blackjack**: Basic strategy still applies",
          "**Live Roulette**: European tables have better odds",
          "**Live Baccarat**: Still bet Banker!",
        ],
        tips: [
          "Games are slower - good for bankroll management",
          "Chat with dealers but stay focused on your bets",
          "Check for live casino bonuses",
          "Internet connection matters - don't play on weak WiFi",
        ],
        rtp: "Same as regular versions",
      },
    };

    // ============================================
    //  ADVANCED BET MARKET PREDICTIONS
    // ============================================
    
    const BET_MARKET_DATA = {
      // Average statistics by league (based on historical data)
      corners: {
        'eng.1': { avgPerMatch: 10.2, homeAvg: 5.4, awayAvg: 4.8, over95: 65, over105: 48, over115: 32 },
        'esp.1': { avgPerMatch: 9.8, homeAvg: 5.2, awayAvg: 4.6, over95: 62, over105: 45, over115: 28 },
        'ger.1': { avgPerMatch: 10.5, homeAvg: 5.6, awayAvg: 4.9, over95: 68, over105: 52, over115: 35 },
        'ita.1': { avgPerMatch: 10.8, homeAvg: 5.7, awayAvg: 5.1, over95: 70, over105: 54, over115: 38 },
        'fra.1': { avgPerMatch: 9.5, homeAvg: 5.0, awayAvg: 4.5, over95: 58, over105: 42, over115: 26 },
        'default': { avgPerMatch: 10.0, homeAvg: 5.3, awayAvg: 4.7, over95: 63, over105: 47, over115: 30 },
      },
      cards: {
        'eng.1': { yellowAvg: 3.2, redChance: 8, totalCardsAvg: 3.4, over25: 62, over35: 38, over45: 18 },
        'esp.1': { yellowAvg: 4.5, redChance: 12, totalCardsAvg: 4.8, over25: 78, over35: 55, over45: 32 },
        'ger.1': { yellowAvg: 3.8, redChance: 9, totalCardsAvg: 4.0, over25: 70, over35: 45, over45: 22 },
        'ita.1': { yellowAvg: 4.2, redChance: 11, totalCardsAvg: 4.5, over25: 75, over35: 52, over45: 28 },
        'fra.1': { yellowAvg: 3.5, redChance: 10, totalCardsAvg: 3.7, over25: 65, over35: 42, over45: 20 },
        'default': { yellowAvg: 3.8, redChance: 10, totalCardsAvg: 4.0, over25: 70, over35: 46, over45: 24 },
      },
      goals: {
        'eng.1': { avgPerMatch: 2.85, bttsYes: 52, over15: 78, over25: 55, over35: 28, cleanSheet: 25 },
        'esp.1': { avgPerMatch: 2.65, bttsYes: 48, over15: 75, over25: 50, over35: 24, cleanSheet: 28 },
        'ger.1': { avgPerMatch: 3.15, bttsYes: 55, over15: 82, over25: 62, over35: 35, cleanSheet: 22 },
        'ita.1': { avgPerMatch: 2.55, bttsYes: 45, over15: 72, over25: 48, over35: 22, cleanSheet: 30 },
        'fra.1': { avgPerMatch: 2.70, bttsYes: 50, over15: 76, over25: 52, over35: 26, cleanSheet: 26 },
        'nba': { avgPerGame: 224.5, over220: 52, over230: 35, under215: 38 },
        'nfl': { avgPerGame: 46.5, over45: 48, over50: 32, under42: 40 },
        'default': { avgPerMatch: 2.75, bttsYes: 50, over15: 76, over25: 52, over35: 26, cleanSheet: 26 },
      },
      fouls: {
        'eng.1': { avgPerMatch: 22, homeAvg: 10, awayAvg: 12 },
        'esp.1': { avgPerMatch: 26, homeAvg: 12, awayAvg: 14 },
        'ita.1': { avgPerMatch: 28, homeAvg: 13, awayAvg: 15 },
        'default': { avgPerMatch: 24, homeAvg: 11, awayAvg: 13 },
      },
      shots: {
        'eng.1': { avgOnTarget: 10.5, homeAvg: 5.8, awayAvg: 4.7 },
        'esp.1': { avgOnTarget: 9.8, homeAvg: 5.5, awayAvg: 4.3 },
        'default': { avgOnTarget: 10.0, homeAvg: 5.5, awayAvg: 4.5 },
      },
    };

    // Function to get bet market predictions
    function getBetMarketPrediction(marketType, league = 'default', homeTeam = null, awayTeam = null) {
      const leagueKey = BET_MARKET_DATA[marketType]?.[league] ? league : 'default';
      const data = BET_MARKET_DATA[marketType]?.[leagueKey];
      
      if (!data) return null;
      
      return {
        market: marketType,
        league: leagueKey,
        stats: data,
        homeTeam,
        awayTeam,
      };
    }

    // Format bet market response with clickable options
    function formatBetMarketResponse(marketType, league, homeTeam, awayTeam) {
      const prediction = getBetMarketPrediction(marketType, league, homeTeam, awayTeam);
      if (!prediction) return null;
      
      const { stats } = prediction;
      let response = '';
      let quickActions = [];
      
      switch (marketType) {
        case 'corners':
          response = ` **Corner Kick Predictions**${homeTeam ? ` - ${homeTeam} vs ${awayTeam}` : ''}\n\n`;
          response += ` **League Average**: ${stats.avgPerMatch} corners per match\n`;
          response += ` Home team avg: ${stats.homeAvg} corners\n`;
          response += ` Away team avg: ${stats.awayAvg} corners\n\n`;
          response += `**Probability Estimates**:\n`;
          response += `• Over 9.5 corners: ${stats.over95}% likely\n`;
          response += `• Over 10.5 corners: ${stats.over105}% likely\n`;
          response += `• Over 11.5 corners: ${stats.over115}% likely\n\n`;
          response += ` **Tip**: High-pressing teams like Liverpool & Man City average 6+ corners per game.\n`;
          quickActions = [
            { text: 'Premier League tips', action: 'give me Premier League tips' },
            { text: 'Live matches', action: 'show live matches' },
            { text: 'Play casino', action: 'show casino games' },
            { text: 'My bonuses', action: 'what bonuses do I have' },
          ];
          break;
          
        case 'cards':
          response = ` **Cards Predictions**${homeTeam ? ` - ${homeTeam} vs ${awayTeam}` : ''}\n\n`;
          response += ` **League Averages**:\n`;
          response += `• Yellow cards: ${stats.yellowAvg} per match\n`;
          response += `• Red card chance: ${stats.redChance}%\n`;
          response += `• Total cards: ${stats.totalCardsAvg} per match\n\n`;
          response += `**Probability Estimates**:\n`;
          response += `• Over 2.5 cards: ${stats.over25}% likely\n`;
          response += `• Over 3.5 cards: ${stats.over35}% likely\n`;
          response += `• Over 4.5 cards: ${stats.over45}% likely\n\n`;
          response += ` **Tip**: Derbies and relegation battles have 40% more cards on average!\n`;
          quickActions = [
            { text: 'Serie A tips', action: 'give me Serie A tips' },
            { text: 'Live matches', action: 'show live matches' },
            { text: 'Play casino', action: 'show casino games' },
            { text: 'My bonuses', action: 'what bonuses do I have' },
          ];
          break;
          
        case 'goals':
          response = ` **Goals Predictions**${homeTeam ? ` - ${homeTeam} vs ${awayTeam}` : ''}\n\n`;
          response += ` **League Averages**:\n`;
          response += `• Goals per match: ${stats.avgPerMatch}\n`;
          response += `• Both Teams Score: ${stats.bttsYes}% of matches\n`;
          response += `• Clean sheet chance: ${stats.cleanSheet}%\n\n`;
          response += `**Probability Estimates**:\n`;
          response += `• Over 1.5 goals: ${stats.over15}% likely\n`;
          response += `• Over 2.5 goals: ${stats.over25}% likely\n`;
          response += `• Over 3.5 goals: ${stats.over35}% likely\n\n`;
          response += ` **Tip**: First 15 mins and last 15 mins see 35% of all goals!\n`;
          quickActions = [
            { text: 'Bundesliga tips', action: 'give me Bundesliga tips' },
            { text: 'Live matches', action: 'show live matches' },
            { text: 'Play casino', action: 'show casino games' },
            { text: 'My bonuses', action: 'what bonuses do I have' },
          ];
          break;
          
        case 'shots':
          response = ` **Shots Predictions**${homeTeam ? ` - ${homeTeam} vs ${awayTeam}` : ''}\n\n`;
          response += ` **League Averages**:\n`;
          response += `• Shots on target: ${stats.avgOnTarget} per match\n`;
          response += `• Home team avg: ${stats.homeAvg} shots on target\n`;
          response += `• Away team avg: ${stats.awayAvg} shots on target\n\n`;
          response += ` **Tip**: Teams chasing goals in 2nd half average 60% more shots!\n`;
          quickActions = [
            { text: 'Premier League tips', action: 'give me Premier League tips' },
            { text: 'Live matches', action: 'show live matches' },
            { text: 'Play casino', action: 'show casino games' },
            { text: 'My bonuses', action: 'what bonuses do I have' },
          ];
          break;
          
        case 'fouls':
          response = ` **Fouls Predictions**${homeTeam ? ` - ${homeTeam} vs ${awayTeam}` : ''}\n\n`;
          response += ` **League Averages**:\n`;
          response += `• Total fouls: ${stats.avgPerMatch} per match\n`;
          response += `• Home team avg: ${stats.homeAvg} fouls\n`;
          response += `• Away team avg: ${stats.awayAvg} fouls\n\n`;
          response += ` **Tip**: Away teams commit ~20% more fouls on average!\n`;
          quickActions = [
            { text: 'Sports tips', action: 'give me sports tips' },
            { text: 'Live matches', action: 'show live matches' },
            { text: 'Play casino', action: 'show casino games' },
            { text: 'My bonuses', action: 'what bonuses do I have' },
          ];
          break;
      }
      
      return { response, quickActions };
    }

    // ============================================
    //  CASINO SESSION TRACKING & RECOMMENDATIONS
    // ============================================
    
    let casinoSession = {
      startTime: null,
      currentGame: null,
      gamesPlayed: [],
      totalWins: 0,
      totalLosses: 0,
      totalSpent: 0,
      totalWon: 0,
    };

    // Simulated casino game data (would come from platform in production)
    const CASINO_GAMES_DATA = {
      games: [
        { id: 'aviator', name: 'Aviator', type: 'crash', rtp: 97, popularity: 95, currentPlayers: 234, recentWins: 12, jackpot: null },
        { id: 'starburst', name: 'Starburst', type: 'slot', rtp: 96.1, popularity: 88, currentPlayers: 156, recentWins: 8, jackpot: null },
        { id: 'book_of_dead', name: 'Book of Dead', type: 'slot', rtp: 96.2, popularity: 82, currentPlayers: 89, recentWins: 5, jackpot: null },
        { id: 'gonzo_quest', name: "Gonzo's Quest", type: 'slot', rtp: 95.9, popularity: 78, currentPlayers: 67, recentWins: 4, jackpot: null },
        { id: 'mega_moolah', name: 'Mega Moolah', type: 'slot', rtp: 88.1, popularity: 70, currentPlayers: 45, recentWins: 1, jackpot: 2500000 },
        { id: 'lightning_roulette', name: 'Lightning Roulette', type: 'live', rtp: 97.3, popularity: 85, currentPlayers: 178, recentWins: 15, jackpot: null },
        { id: 'blackjack_live', name: 'Live Blackjack', type: 'live', rtp: 99.5, popularity: 80, currentPlayers: 123, recentWins: 20, jackpot: null },
        { id: 'crazy_time', name: 'Crazy Time', type: 'live', rtp: 96.0, popularity: 92, currentPlayers: 289, recentWins: 18, jackpot: null },
        { id: 'sweet_bonanza', name: 'Sweet Bonanza', type: 'slot', rtp: 96.5, popularity: 86, currentPlayers: 134, recentWins: 9, jackpot: null },
        { id: 'gates_of_olympus', name: 'Gates of Olympus', type: 'slot', rtp: 96.5, popularity: 84, currentPlayers: 112, recentWins: 7, jackpot: null },
        { id: 'spaceman', name: 'Spaceman', type: 'crash', rtp: 96, popularity: 75, currentPlayers: 56, recentWins: 6, jackpot: null },
        { id: 'plinko', name: 'Plinko', type: 'instant', rtp: 97, popularity: 72, currentPlayers: 34, recentWins: 11, jackpot: null },
      ],
    };

    // Start casino session tracking
    function startCasinoSession(gameName) {
      if (!casinoSession.startTime) {
        casinoSession.startTime = Date.now();
      }
      casinoSession.currentGame = gameName;
      if (!casinoSession.gamesPlayed.includes(gameName)) {
        casinoSession.gamesPlayed.push(gameName);
      }
    }

    // Get session duration in minutes
    function getSessionDuration() {
      if (!casinoSession.startTime) return 0;
      return Math.floor((Date.now() - casinoSession.startTime) / 60000);
    }

    // Get casino recommendations based on user behavior
    function getCasinoRecommendations(context = {}) {
      const { 
        currentGame = null,
        sessionMinutes = getSessionDuration(),
        winRate = casinoSession.totalWins / (casinoSession.totalWins + casinoSession.totalLosses + 1),
        gamesPlayed = casinoSession.gamesPlayed,
      } = context;

      const recommendations = [];
      const games = CASINO_GAMES_DATA.games;
      
      // Find games user hasn't played
      const unplayedGames = games.filter(g => !gamesPlayed.includes(g.name));
      
      // Recommendation 1: Long session - suggest a break or change
      if (sessionMinutes >= 20) {
        const differentTypeGames = games.filter(g => {
          const currentGameData = games.find(cg => cg.name === currentGame);
          return currentGameData && g.type !== currentGameData.type && !gamesPlayed.includes(g.name);
        });
        if (differentTypeGames.length > 0) {
          const suggested = differentTypeGames.sort((a, b) => b.popularity - a.popularity)[0];
          recommendations.push({
            type: 'session_change',
            reason: `You've been playing for ${sessionMinutes} minutes`,
            game: suggested,
            message: ` **${suggested.name}** has ${suggested.currentPlayers} players online right now!`,
          });
        }
      }
      
      // Recommendation 2: Low win rate - suggest higher RTP game
      if (winRate < 0.3 && (casinoSession.totalWins + casinoSession.totalLosses) >= 5) {
        const highRtpGames = games.filter(g => g.rtp >= 96.5 && g.name !== currentGame);
        if (highRtpGames.length > 0) {
          const suggested = highRtpGames.sort((a, b) => b.rtp - a.rtp)[0];
          recommendations.push({
            type: 'better_odds',
            reason: 'Looking for a change of luck?',
            game: suggested,
            message: ` **${suggested.name}** has ${suggested.rtp}% payout rate - great for winning!`,
          });
        }
      }
      
      // Recommendation 3: Popular games - join the fun
      const popularGames = games
        .filter(g => g.name !== currentGame && g.currentPlayers > 100)
        .sort((a, b) => b.currentPlayers - a.currentPlayers);
      if (popularGames.length > 0) {
        recommendations.push({
          type: 'popular',
          reason: 'Join the action!',
          game: popularGames[0],
          message: ` **${popularGames[0].name}** - ${popularGames[0].currentPlayers} players online, ${popularGames[0].recentWins} wins in the last hour!`,
        });
      }
      
      // Recommendation 4: Recent wins on another game
      const hotGames = games
        .filter(g => g.name !== currentGame && g.recentWins >= 8)
        .sort((a, b) => b.recentWins - a.recentWins);
      if (hotGames.length > 0) {
        recommendations.push({
          type: 'hot_game',
          reason: 'Games paying out right now',
          game: hotGames[0],
          message: ` **${hotGames[0].name}** - ${hotGames[0].recentWins} wins in the last hour!`,
        });
      }
      
      // Recommendation 5: Low activity game - potential bigger wins
      const quietGames = games
        .filter(g => g.name !== currentGame && g.currentPlayers < 50 && g.rtp >= 95)
        .sort((a, b) => a.currentPlayers - b.currentPlayers);
      if (quietGames.length > 0) {
        recommendations.push({
          type: 'quiet_game',
          reason: 'Less competition',
          game: quietGames[0],
          message: ` **${quietGames[0].name}** - Only ${quietGames[0].currentPlayers} players, could be your moment!`,
        });
      }
      
      // Recommendation 6: Jackpot games
      const jackpotGames = games.filter(g => g.jackpot && g.jackpot > 1000000 && g.name !== currentGame);
      if (jackpotGames.length > 0) {
        const jp = jackpotGames[0];
        recommendations.push({
          type: 'jackpot',
          reason: 'Life-changing win potential',
          game: jp,
          message: ` **${jp.name}** - ZMW ${(jp.jackpot).toLocaleString()} jackpot waiting!`,
        });
      }
      
      // Recommendation 7: Try something new
      if (unplayedGames.length > 0 && gamesPlayed.length >= 1) {
        const newGame = unplayedGames.sort((a, b) => b.popularity - a.popularity)[0];
        recommendations.push({
          type: 'try_new',
          reason: 'Expand your horizons',
          game: newGame,
          message: ` **${newGame.name}** - Popular game you haven't tried yet!`,
        });
      }
      
      return recommendations.slice(0, 4); // Return max 4 recommendations
    }

    // Format casino recommendations with clickable options
    function formatCasinoRecommendations(currentGame = null) {
      const recs = getCasinoRecommendations({ currentGame });
      
      let response = "**Games You Might Enjoy**:\n\n";
      
      recs.forEach((rec, i) => {
        response += `${rec.message}\n`;
      });
      
      const quickActions = recs.map(rec => ({
        text: ` ${rec.game.name}`,
        action: `tell me about ${rec.game.name}`,
      }));
      
      // Add some standard actions
      quickActions.push({ text: 'Casino strategies', action: 'casino strategies' });
      
      return { response, quickActions: quickActions.slice(0, 4) };
    }

    // ============================================
    //  CLICKABLE QUICK ACTIONS SYSTEM
    // ============================================
    
    // Generate quick action buttons HTML
    function generateQuickActionsHTML(actions) {
      if (!actions || actions.length === 0) return '';
      
      let html = '<div class="quick-actions-container">';
      actions.forEach(action => {
        html += `<button class="quick-action" onclick="handleQuickAction('${action.action.replace(/'/g, "\\'")}')">${action.text}</button>`;
      });
      html += '</div>';
      return html;
    }

    // Handle quick action click
    function handleQuickAction(action) {
      document.getElementById('messageInput').value = action;
      sendMessage();
    }

    // Detect the topic from user message to provide relevant quick actions
    function detectMessageTopic(message) {
      const msg = message.toLowerCase().trim();
      
      // Casino-specific keywords (high confidence)
      const casinoKeywords = ['casino', 'slot', 'slots', 'roulette', 'blackjack', 'poker', 'baccarat', 'aviator', 'crash game', 'live dealer', 'jackpot', 'spin', 'rtp', 'crazy time', 'lightning', 'starburst', 'book of dead', 'sweet bonanza', 'spaceman', 'plinko', 'mega moolah'];
      
      // Sports-specific keywords (high confidence) - includes "tips" with sports context
      const sportsKeywords = ['match', 'team', 'league', 'premier league', 'epl', 'la liga', 'serie a', 'bundesliga', 'champions league', 'nba', 'nfl', 'mlb', 'nhl', 'soccer', 'football match', 'basketball', 'tennis', 'golf', 'ufc', 'boxing', 'f1', 'formula', 'racing', 'cricket', 'rugby', 'corner', 'corners', 'goals', 'btts', 'both teams', 'score', 'standings', 'fixture', 'liverpool', 'manchester', 'arsenal', 'chelsea', 'barcelona', 'real madrid', 'lakers', 'celtics', 'warriors', 'picks', 'predictions'];
      
      // Strategy-related keywords - NOTE: "tips" is NOT here, it's context-dependent
      const strategyKeywords = ['strategy', 'strategies', 'how to win', 'bankroll', 'martingale', 'system', 'how to play'];
      
      // Help/general keywords
      const helpKeywords = ['help', 'what can you', 'how do i', 'explain', 'what is'];
      
      // Count matches for each category
      let casinoScore = 0;
      let sportsScore = 0;
      let strategyScore = 0;
      let helpScore = 0;
      
      casinoKeywords.forEach(k => { if (msg.includes(k)) casinoScore++; });
      sportsKeywords.forEach(k => { if (msg.includes(k)) sportsScore++; });
      strategyKeywords.forEach(k => { if (msg.includes(k)) strategyScore++; });
      helpKeywords.forEach(k => { if (msg.includes(k)) helpScore++; });
      
      // Handle "tips" contextually - if sports keywords present, it's sports tips
      if (msg.includes('tip')) {
        if (sportsScore > 0) {
          sportsScore += 2; // Boost sports if "tips" + sports context
        } else if (casinoScore > 0) {
          strategyScore += 1; // Casino tips = strategy
        }
      }
      
      // Special case: if asking about casino strategy
      if (strategyScore > 0 && casinoScore > 0) return 'strategy';
      
      // Determine the highest scoring topic
      const scores = [
        { topic: 'casino', score: casinoScore },
        { topic: 'sports', score: sportsScore },
        { topic: 'strategy', score: strategyScore },
        { topic: 'help', score: helpScore },
      ];
      
      scores.sort((a, b) => b.score - a.score);
      
      // If no clear winner or all zero, return greeting (balanced options)
      if (scores[0].score === 0) return 'greeting';
      
      return scores[0].topic;
    }

    // Generate engaging quick actions that guide users toward betting decisions
    function generateSmartQuickActions(userMessage, aiResponse = '') {
      const msg = userMessage.toLowerCase().trim();
      const response = aiResponse.toLowerCase();
      
      // =====================================================
      // QUICK ACTIONS - First 2 are binary, then 2 more options
      // =====================================================
      
      // Check for MATCH patterns in AI response
      const matchPattern = /\*\*([A-Za-z\s]+)\s+vs\s+([A-Za-z\s]+)\*\*/gi;
      const matches = [...aiResponse.matchAll(matchPattern)];
      
      if (matches.length > 0) {
        const firstMatch = matches[0];
        const homeTeam = firstMatch[1].trim();
        const awayTeam = firstMatch[2].trim();
        
        // Sports match detected - binary first, then extras
        return [
          { text: 'How do I place this bet?', action: `show me how to place a bet on ${homeTeam} vs ${awayTeam}` },
          { text: 'Show me a different match', action: 'show me other matches today' },
          { text: `More on ${homeTeam}`, action: `give me full analysis on ${homeTeam}` },
          { text: 'Play casino', action: 'show me casino games' },
        ];
      }
      
      // Check for sports content
      const hasSportsContent = response.includes('to win') || response.includes('pick:') || response.includes('confidence') || response.includes('over 2.5') || response.includes('both teams');
      if (hasSportsContent) {
        return [
          { text: 'How do I place this?', action: 'show me step by step how to place this bet' },
          { text: 'Show me another pick', action: 'show me a different betting pick' },
          { text: 'Safer option', action: 'show me a safer betting option' },
          { text: 'Play casino', action: 'show me casino games' },
        ];
      }
      
      // Check for casino content
      const hasCasinoContent = response.includes('aviator') || response.includes('blackjack') || response.includes('roulette') || response.includes('cash out') || response.includes('multiplier');
      if (hasCasinoContent) {
        return [
          { text: 'Where do I find this game?', action: 'show me where to find this game on Bwanabet' },
          { text: 'Show me a different game', action: 'recommend a different casino game' },
          { text: 'More winning tips', action: 'give me more tips to win at this game' },
          { text: 'Try sports betting', action: 'show me sports betting picks' },
        ];
      }
      
      // Check for explanation/educational content
      const isExplanation = response.includes('how it works') || response.includes('meaning') || response.includes('means that') || msg.includes('what is') || msg.includes('explain');
      if (isExplanation) {
        return [
          { text: 'I understand, show me picks', action: 'now show me some betting picks' },
          { text: 'Explain more', action: 'explain this in more detail' },
          { text: 'Show me examples', action: 'show me examples of this bet type' },
          { text: 'Play casino', action: 'show me casino games' },
        ];
      }
      
      // Check for strategy content
      const isStrategy = response.includes('strategy') || response.includes('tip:') || response.includes('pro tip');
      if (isStrategy) {
        return [
          { text: 'Let me try this', action: 'show me where to play this' },
          { text: 'More strategies', action: 'give me more winning strategies' },
          { text: 'Beginner tips', action: 'give me beginner-friendly tips' },
          { text: 'Try sports betting', action: 'show me sports betting picks' },
        ];
      }
      
      // Check if user asked about finding something
      const isFindingHelp = msg.includes('where') || msg.includes('find') || msg.includes('how do i');
      if (isFindingHelp) {
        return [
          { text: 'Got it, show me picks', action: 'now give me some betting picks' },
          { text: 'I need more help', action: 'I still need help finding this' },
          { text: 'Show me something else', action: 'show me other options' },
          { text: 'Play casino', action: 'show me casino games' },
        ];
      }
      
      // Default based on user preference
      if (userPreference === 'casino') {
        return [
          { text: 'Show me casino games', action: 'show me top casino games' },
          { text: 'Try sports betting', action: 'show me sports betting picks' },
          { text: 'Winning strategies', action: 'teach me casino winning strategies' },
          { text: 'Best payouts', action: 'which games have best payout rates' },
        ];
      }
      
      if (userPreference === 'sports') {
        return [
          { text: 'Show me sports picks', action: 'show me today\'s best picks' },
          { text: 'Try casino games', action: 'show me casino games' },
          { text: 'Different league', action: 'show me picks from a different league' },
          { text: 'Betting tips', action: 'give me general betting tips' },
        ];
      }
      
      // Fallback
      return [
        { text: 'Sports Betting', action: 'show me sports betting picks for today' },
        { text: 'Casino Games', action: 'show me casino games' },
        { text: 'How betting works', action: 'explain how betting works' },
        { text: 'Winning tips', action: 'give me tips to win more' },
      ];
    }
    function getCasinoStrategy(game) {
      const gameLower = game.toLowerCase();
      const gameKey = gameLower.replace(/\s+/g, '_');
      
      // Explicit game name mappings
      const gameAliases = {
        'sweet bonanza': 'sweet_bonanza',
        'gates of olympus': 'gates_of_olympus',
        'gates': 'gates_of_olympus',
        'olympus': 'gates_of_olympus',
        'mega moolah': 'mega_moolah',
        'moolah': 'mega_moolah',
        'lightning roulette': 'lightning_roulette',
        'lightning': 'lightning_roulette',
        'crazy time': 'crazy_time',
        'plinko': 'plinko',
        'spaceman': 'spaceman',
        'live dealer': 'live_dealer',
        'live casino': 'live_dealer',
        'live': 'live_dealer',
      };
      
      // Check aliases first
      if (gameAliases[gameLower]) {
        return CASINO_STRATEGIES[gameAliases[gameLower]];
      }
      
      // Find matching strategy by key or name
      for (const [key, data] of Object.entries(CASINO_STRATEGIES)) {
        if (key === gameKey || data.name.toLowerCase() === gameLower) {
          return data;
        }
      }
      
      // Fuzzy match
      for (const [key, data] of Object.entries(CASINO_STRATEGIES)) {
        if (gameLower.includes(key) || key.includes(gameLower) || 
            gameLower.includes(data.name.toLowerCase()) || data.name.toLowerCase().includes(gameLower)) {
          return data;
        }
      }
      
      return null;
    }

    // Format strategy response with quick actions - SHORT BULLETS
    function formatStrategyResponse(strategy) {
      const bonus = getActiveBonus();
      const recentWinner = getRecentWinner();
      
      let response = `**${strategy.name}** - Let's get you winning!\n\n`;
      
      // Quick hook
      response += `${strategy.description}\n\n`;
      
      // Winning strategy (make it feel actionable)
      response += `**Your Winning Strategy:**\n`;
      if (strategy.strategies && strategy.strategies.length > 0) {
        // Clean and simplify first 2 strategies
        const strat1 = strategy.strategies[0].replace(/^\*\*[^*]+\*\*:?\s*/, '').replace(/^[•\-\d.]+\s*/, '');
        response += `- ${strat1}\n`;
        if (strategy.strategies[1]) {
          const strat2 = strategy.strategies[1].replace(/^\*\*[^*]+\*\*:?\s*/, '').replace(/^[•\-\d.]+\s*/, '');
          response += `- ${strat2}\n`;
        }
      }
      
      // Pro tip (creates expertise feel)
      response += `\n**Pro Tip:** ${strategy.tips && strategy.tips[0] ? strategy.tips[0] : 'Start with small bets until comfortable'}\n`;
      
      // Social proof + payout
      response += `\n- Payout: ${strategy.rtp}`;
      if (recentWinner && recentWinner.game && recentWinner.game.toLowerCase().includes(strategy.name.toLowerCase().split(' ')[0])) {
        response += ` - ${recentWinner.player} just won ZMW ${recentWinner.amount.toLocaleString()}!`;
      }
      response += '\n';
      
      // Bonus reminder (urgency)
      if (bonus) {
        response += `\nYour ${bonus.label} is ready - use it now!\n`;
      }
      
      // [MORE] for those who want deeper info
      if (strategy.howToPlay && strategy.howToPlay.length > 0) {
        let moreContent = `**How to Play:** ${strategy.howToPlay.slice(0, 3).join(' ')}`;
        if (strategy.tips && strategy.tips.length > 1) {
          moreContent += ` **More Tips:** ${strategy.tips[1]}`;
        }
        response += `\n[MORE]${moreContent}[/MORE]`;
      }
      
      return response;
    }

    // Enhanced getInstantResponse - returns { response, quickActions } or null
    function getInstantResponse(message) {
      const msg = message.toLowerCase().trim();
      let response = null;
      let quickActions = [];
      
      // ============================================
      // FAQ KNOWLEDGE BASE - Check first for instant answers
      // ============================================
      
      const faqResult = searchFAQ(msg);
      if (faqResult) {
        updateUserMemory(msg, faqResult.response, faqResult.matched);
        const nextSteps = getContextualNextSteps(faqResult.nextSteps, msg);
        return { 
          response: faqResult.response, 
          quickActions: nextSteps 
        };
      }
      
      // ============================================
      // CONTEXT DETECTION - Used throughout the function
      // ============================================
      
      // Sports context keywords - if any of these appear, it's likely sports-related
      const sportsExcludeKeywords = ['epl', 'premier', 'league', 'la liga', 'serie', 'bundesliga', 'champions', 'europa', 'nba', 'nfl', 'mlb', 'nhl', 'ufc', 'soccer', 'football', 'basketball', 'tennis', 'golf', 'cricket', 'rugby', 'match', 'matches', 'team', 'teams', 'liverpool', 'manchester', 'arsenal', 'chelsea', 'tottenham', 'barcelona', 'real madrid', 'juventus', 'bayern', 'psg', 'lakers', 'celtics', 'warriors', 'corner', 'corners', 'goal', 'goals', 'btts', 'standings', 'fixture', 'fixtures', 'odds', 'score', 'scores', 'halftime', 'fulltime', 'handicap'];
      const hasSportsContext = sportsExcludeKeywords.some(k => msg.includes(k));
      
      // Casino context keywords - specific casino game names
      const casinoGameNames = ['aviator', 'blackjack', 'roulette', 'slots', 'slot', 'poker', 'baccarat', 'crash', 'live dealer', 'live casino', 'crazy time', 'starburst', 'plinko', 'sweet bonanza', 'book of dead', 'mega moolah', 'lightning', 'spaceman', 'gates of olympus', 'gates'];
      const hasCasinoKeyword = msg.includes('casino') || casinoGameNames.some(g => msg.includes(g));
      
      // ============================================
      // BET MARKET PREDICTIONS (Corners, Cards, Goals, etc.)
      // ============================================
      
      // Corner predictions
      if (msg.includes('corner') && (msg.includes('predict') || msg.includes('how many') || msg.includes('over') || msg.includes('under') || msg.includes('tip'))) {
        const result = formatBetMarketResponse('corners', 'eng.1');
        return { response: result.response, quickActions: result.quickActions };
      }
      
      // Cards predictions
      if ((msg.includes('card') || msg.includes('yellow') || msg.includes('red card') || msg.includes('booking')) && 
          (msg.includes('predict') || msg.includes('how many') || msg.includes('over') || msg.includes('tip'))) {
        const result = formatBetMarketResponse('cards', 'eng.1');
        return { response: result.response, quickActions: result.quickActions };
      }
      
      // Goals predictions
      if ((msg.includes('goal') || msg.includes('btts') || msg.includes('both teams') || msg.includes('over 2.5') || msg.includes('over 1.5')) && 
          (msg.includes('predict') || msg.includes('how many') || msg.includes('tip') || msg.includes('score'))) {
        const result = formatBetMarketResponse('goals', 'eng.1');
        return { response: result.response, quickActions: result.quickActions };
      }
      
      // Shots predictions
      if (msg.includes('shot') && (msg.includes('predict') || msg.includes('how many') || msg.includes('target'))) {
        const result = formatBetMarketResponse('shots', 'eng.1');
        return { response: result.response, quickActions: result.quickActions };
      }
      
      // Fouls predictions
      if (msg.includes('foul') && (msg.includes('predict') || msg.includes('how many'))) {
        const result = formatBetMarketResponse('fouls', 'eng.1');
        return { response: result.response, quickActions: result.quickActions };
      }
      
      // All betting markets
      if (msg.includes('betting market') || msg.includes('all market') || msg.includes('what bets') || msg.includes('types of bet') || msg.includes('bet types') || msg.includes('other bet')) {
        response = "**Betting Markets**\n" +
                   "- Match Result (1X2) - Pick winner/draw\n" +
                   "- Double Chance - Cover 2 outcomes\n" +
                   "- Over/Under Goals - 1.5, 2.5, 3.5\n" +
                   "- Both Teams Score - Yes/No\n" +
                   "- Corners - Over/Under 9.5\n" +
                   "- Cards - Over/Under 3.5\n\n" +
                   "[MORE]Match Result has highest payouts but more risk. Double Chance is safer with lower returns. Over/Under 2.5 Goals is most popular market.[/MORE]";
        quickActions = [
          { text: 'Match Result tips', action: 'give me match result predictions' },
          { text: 'Double Chance tips', action: 'give me double chance predictions' },
          { text: 'Goals tips', action: 'give me goals predictions' },
          { text: 'Corners tips', action: 'give me corner predictions' },
        ];
        return { response, quickActions };
      }
      
      // Explain specific bet types
      if (msg.includes('explain') && (msg.includes('double chance') || msg.includes('1x2') || msg.includes('match result'))) {
        response = "**Double Chance**\n" +
                   "- 1X = Home Win OR Draw\n" +
                   "- X2 = Draw OR Away Win\n" +
                   "- 12 = Home OR Away (no draw)\n" +
                   "- Safer bet, lower payout\n\n" +
                   "[MORE]Best for close matches where draw is likely. Use 1X for strong home teams, X2 for away favorites.[/MORE]";
        quickActions = [
          { text: 'Find DC bets', action: 'find good double chance bets today' },
          { text: 'Premier League tips', action: 'give me Premier League tips' },
          { text: 'La Liga tips', action: 'give me La Liga tips' },
          { text: 'Play casino', action: 'show casino games' },
        ];
        return { response, quickActions };
      }
      
      // Explain corner bets
      if (msg.includes('explain') && msg.includes('corner')) {
        response = "**Corner Bets**\n" +
                   "- Over/Under 9.5 - Standard line\n" +
                   "- Over/Under 10.5 - Higher payout\n" +
                   "- Premier League avg: 10.2\n" +
                   "- La Liga avg: 9.8\n\n" +
                   "[MORE]Attacking teams generate more corners. Derby matches typically have 11+ corners. Check team formations - 4-3-3 creates more corners than 5-4-1.[/MORE]";
        quickActions = [
          { text: 'Corner predictions', action: 'give me corner predictions for today' },
          { text: 'Premier League tips', action: 'give me Premier League tips' },
          { text: 'NBA tips', action: 'give me NBA tips' },
          { text: 'Play casino', action: 'show casino games' },
        ];
        return { response, quickActions };
      }
      
      // Explain card bets
      if (msg.includes('explain') && (msg.includes('card') || msg.includes('booking') || msg.includes('yellow') || msg.includes('red'))) {
        response = "**Card Bets**\n" +
                   "- Over/Under 3.5 cards - Standard\n" +
                   "- Over/Under 4.5 cards - Fiery matches\n" +
                   "- Premier League avg: 3.2 yellows\n" +
                   "- La Liga avg: 4.5 yellows\n\n" +
                   "[MORE]Derby matches have 40% more cards. Check referee history - some average 5+ cards per game. Relegation battles are card-heavy.[/MORE]";
        quickActions = [
          { text: 'Card predictions', action: 'give me card predictions for today' },
          { text: 'Premier League tips', action: 'give me Premier League tips' },
          { text: 'Serie A tips', action: 'give me Serie A tips' },
          { text: 'Play casino', action: 'show casino games' },
        ];
        return { response, quickActions };
      }
      
      // ============================================
      // CASINO GAME RECOMMENDATIONS
      // ============================================
      
      // Popular games request - only if NOT sports context
      if (!hasSportsContext && msg.includes('popular') && (msg.includes('game') || msg.includes('casino'))) {
        startCasinoSession('browsing');
        const games = CASINO_GAMES_DATA.games.sort((a, b) => b.currentPlayers - a.currentPlayers).slice(0, 5);
        const engagement = getEngagementContext();
        response = "**Hot Games Now**\n";
        games.slice(0, 4).forEach((g, i) => {
          response += `- ${g.name} - ${g.currentPlayers} playing\n`;
        });
        if (engagement.bonus) {
          response += `\nBonus: ${engagement.bonus.label} expires ${engagement.bonus.timeLeft}`;
        }
        quickActions = [
          { text: `Play ${games[0].name}`, action: `how do I win at ${games[0].name}` },
          { text: `Play ${games[1].name}`, action: `how do I win at ${games[1].name}` },
          { text: 'Best payout games', action: 'show games with best payout' },
          { text: 'Sports picks', action: 'show me hot sports picks' },
        ];
        return { response, quickActions };
      }
      
      // SHOW ME CASINO GAMES - Short, engaging response
      if (!hasSportsContext && (msg === 'show me casino games' || msg === 'casino games' || msg === 'show casino games' || (msg.includes('show') && msg.includes('casino') && msg.includes('game')))) {
        startCasinoSession('browsing');
        
        if (userMode === 'beginner') {
          response = "**Casino Games for Beginners:**\n\n";
          response += "**Aviator** - A plane takes off, cash out before it flies away!\n";
          response += "**Blackjack** - Get cards that add up to 21 to beat the dealer\n";
          response += "**Roulette** - Pick a color (red/black) or number, spin the wheel\n\n";
          response += "I recommend starting with **Aviator** - it's the easiest to learn.\n\n";
          response += "**Ready to go?**";
        } else {
          response = "**Top Casino Games by RTP:**\n\n";
          response += "- **Blackjack** - 99.5% RTP (highest edge)\n";
          response += "- **European Roulette** - 97.3% RTP\n";
          response += "- **Aviator** - 97.0% RTP (crash game)\n";
          response += "- **Baccarat** - 98.9% RTP (banker bet)\n\n";
          response += "**Ready to go?**";
        }
        
        quickActions = [
          { text: 'Teach me Aviator', action: 'teach me how to play and win at Aviator' },
          { text: 'Teach me Blackjack', action: 'teach me how to play and win at Blackjack' },
          { text: 'Best payout games', action: 'which casino games have the best payout rates' },
          { text: 'Try sports betting', action: 'show me sports betting picks' },
        ];
        return { response, quickActions };
      }
      
      // High payout games
      if (!hasSportsContext && (msg.includes('high') && msg.includes('rtp') || msg.includes('best odds') && msg.includes('casino'))) {
        const games = CASINO_GAMES_DATA.games.sort((a, b) => b.rtp - a.rtp).slice(0, 4);
        response = "**Best Payout Games:**\n\n";
        games.forEach((g) => {
          response += `- **${g.name}** - ${g.rtp}% payout rate\n`;
        });
        response += `\n**Ready to go?**`;
        quickActions = [
          { text: `Learn ${games[0].name}`, action: `teach me how to win at ${games[0].name}` },
          { text: `Learn ${games[1].name}`, action: `teach me how to win at ${games[1].name}` },
          { text: 'Hot games now', action: 'which games are paying out right now' },
          { text: 'Try sports betting', action: 'show me sports betting picks' },
        ];
        return { response, quickActions };
      }
      
      // Hot games / games paying out - casino only
      if (!hasSportsContext && (msg.includes('hot') || msg.includes('paying') || msg.includes('winning')) && (msg.includes('game') || msg.includes('casino') || msg.includes('slot'))) {
        const games = CASINO_GAMES_DATA.games.sort((a, b) => b.recentWins - a.recentWins).slice(0, 4);
        response = "**Hot Games Right Now:**\n\n";
        games.forEach((g) => {
          response += `- **${g.name}** - ${g.recentWins} wins in the last hour\n`;
        });
        response += `\n**Ready to go?**`;
        quickActions = [
          { text: `Play ${games[0].name}`, action: `teach me how to win at ${games[0].name}` },
          { text: `Play ${games[1].name}`, action: `teach me how to win at ${games[1].name}` },
          { text: 'Best payout games', action: 'show me games with best payout rates' },
          { text: 'Try sports betting', action: 'show me sports betting picks' },
          { text: 'Sports picks', action: 'give me hot sports picks too' },
        ];
        return { response, quickActions };
      }
      
      // Casino game recommendations based on session - only if asking about casino
      if (!hasSportsContext && (msg.includes('recommend') && (msg.includes('casino') || msg.includes('slot') || msg.includes('play')) || msg.includes('what should i play'))) {
        const result = formatCasinoRecommendations(casinoSession.currentGame);
        return { response: result.response, quickActions: result.quickActions };
      }
      
      // Specific game info
      for (const game of CASINO_GAMES_DATA.games) {
        if (msg.includes(game.name.toLowerCase()) && (msg.includes('tell') || msg.includes('about') || msg.includes('info') || msg.includes('win') || msg.includes('how'))) {
          startCasinoSession(game.name);
          response = ` **${game.name}** - Let's get you winning!\n\n`;
          response += ` **Payout Rate**: ${game.rtp}% (${game.rtp > 96 ? 'Great returns!' : 'Solid game!'})\n`;
          response += ` **Players Online**: ${game.currentPlayers} playing now\n`;
          response += ` **Recent Wins**: ${game.recentWins} in the last hour! \n`;
          response += ` **Type**: ${game.type.charAt(0).toUpperCase() + game.type.slice(1)}\n`;
          if (game.jackpot) {
            response += ` **JACKPOT**: ZMW ${game.jackpot.toLocaleString()} up for grabs!\n`;
          }
          response += `\nReady to win? Let me show you how! `;
          
          // Find similar games
          const similarGames = CASINO_GAMES_DATA.games
            .filter(g => g.type === game.type && g.id !== game.id)
            .slice(0, 2);
          
          quickActions = [
            { text: ` ${game.name} tips`, action: `how do I win at ${game.name}` },
            { text: 'What\'s hot', action: 'which games are paying out now' },
          ];
          if (similarGames.length > 0) {
            quickActions.push({ text: ` Try ${similarGames[0].name}`, action: `how do I win at ${similarGames[0].name}` });
          }
          quickActions.push({ text: 'Sports picks', action: 'show me hot sports picks' });
          return { response, quickActions };
        }
      }
      
      // ============================================
      // CASINO STRATEGY REQUESTS - INSTANT
      // ============================================
      
      const strategyKeywords = ['strategy', 'strategies', 'how to play', 'how do i play', 'how to win', 'best way to play'];
      const isStrategyRequest = strategyKeywords.some(k => msg.includes(k));
      
      // Only handle as casino strategy if there's specific casino context AND strategy keywords
      if (isStrategyRequest && hasCasinoKeyword && !hasSportsContext) {
        for (const game of casinoGameNames) {
          if (msg.includes(game)) {
            const strategy = getCasinoStrategy(game);
            if (strategy) {
              response = formatStrategyResponse(strategy);
              quickActions = [
                { text: 'Play now', action: `which ${game} games are hot right now` },
                { text: 'Hot games', action: 'which games are paying out right now' },
                { text: 'Best payout', action: 'games with best payout' },
                { text: 'Sports picks', action: 'show me hot sports picks too' },
              ];
              return { response, quickActions };
            }
          }
        }
        // General casino strategy request (only if explicitly asking about casino)
        if (msg.includes('casino')) {
          response = "Let me help you win Bwana! \n\n" +
                 " **Aviator** - Know when to cash out\n" +
                 " **Blackjack** - Beat the dealer consistently\n" +
                 " **Roulette** - Smart betting systems\n" +
                 " **Slots** - Maximize your spins\n" +
                 " **Baccarat** - The banker's secret\n\n" +
                 "Which game are you playing? ";
          quickActions = [
            { text: 'Win at Aviator', action: 'how do I win at aviator' },
            { text: 'Win at Blackjack', action: 'how do I win at blackjack' },
            { text: 'Win at Roulette', action: 'how do I win at roulette' },
            { text: 'Hot games now', action: 'which games are paying out' },
          ];
          return { response, quickActions };
        }
      }
      
      // Direct game mentions asking for strategy - must have specific game name
      if (msg.includes('aviator') && (msg.includes('how') || msg.includes('tip') || msg.includes('strat') || msg.includes('win') || msg.includes('teach'))) {
        response = formatStrategyResponse(CASINO_STRATEGIES.aviator);
        response += `\n\n**Ready to go?**`;
        quickActions = [
          { text: 'Where do I find Aviator?', action: 'show me exactly where Aviator is on Bwanabet' },
          { text: 'Show me a different game', action: 'recommend a different casino game' },
          { text: 'More Aviator tips', action: 'give me advanced Aviator strategies' },
          { text: 'Try sports betting', action: 'show me sports betting picks' },
        ];
        return { response, quickActions };
      }
      
      if (msg.includes('blackjack') && (msg.includes('how') || msg.includes('tip') || msg.includes('strat') || msg.includes('win') || msg.includes('teach'))) {
        response = formatStrategyResponse(CASINO_STRATEGIES.blackjack);
        response += `\n\n**Ready to go?**`;
        quickActions = [
          { text: 'Where do I find Blackjack?', action: 'show me exactly where Blackjack is on Bwanabet' },
          { text: 'Show me a different game', action: 'recommend a different casino game' },
          { text: 'Advanced Blackjack tips', action: 'teach me card counting and advanced strategy' },
          { text: 'Try sports betting', action: 'show me sports betting picks' },
        ];
        return { response, quickActions };
      }
      
      if (msg.includes('roulette') && (msg.includes('how') || msg.includes('tip') || msg.includes('strat') || msg.includes('win') || msg.includes('teach'))) {
        response = formatStrategyResponse(CASINO_STRATEGIES.roulette);
        response += `\n\n**Ready to go?**`;
        quickActions = [
          { text: 'Where do I find Roulette?', action: 'show me exactly where Roulette is on Bwanabet' },
          { text: 'Show me a different game', action: 'recommend a different casino game' },
          { text: 'Roulette betting systems', action: 'explain roulette betting systems like Martingale' },
          { text: 'Try sports betting', action: 'show me sports betting picks' },
        ];
        return { response, quickActions };
      }
      
      if ((msg.includes('slot') || msg.includes('slots')) && (msg.includes('how') || msg.includes('tip') || msg.includes('strat') || msg.includes('win') || msg.includes('teach'))) {
        response = formatStrategyResponse(CASINO_STRATEGIES.slots);
        response += `\n\n**Ready to go?**`;
        quickActions = [
          { text: 'Where do I find Slots?', action: 'show me where to find slots on Bwanabet' },
          { text: 'Show me a different game', action: 'recommend a different casino game' },
          { text: 'Best slots to play', action: 'which slots have the best payout rates' },
          { text: 'Try sports betting', action: 'show me sports betting picks' },
        ];
        return { response, quickActions };
      }
      
      // Casino games list
      if (msg === 'casino' || msg === 'casino games' || msg.includes('what casino games') || msg.includes('show casino') || msg.includes('all casino')) {
        const bonus = getActiveBonus();
        response = "**Casino Games**\n" +
               "- Aviator - High activity\n" +
               "- Crazy Time - Bonus rounds\n" +
               "- Blackjack - 99.5% payout\n" +
               "- Mega Moolah - ZMW 2.5M jackpot";
        if (bonus) {
          response += `\n- Bonus: ${bonus.label} - ${bonus.timeLeft}`;
        }
        response += "\n\n[MORE]Aviator and Crazy Time are trending with most players. Blackjack offers best mathematical odds. Mega Moolah has largest progressive jackpot.[/MORE]";
        quickActions = [
          { text: 'Play Aviator', action: 'tell me how to win at Aviator' },
          { text: 'Jackpot games', action: 'show me the biggest jackpots' },
          { text: 'Use my bonus', action: 'help me use my casino bonus' },
          { text: 'Sports analysis', action: 'show me hot sports picks while I play' },
        ];
        return { response, quickActions };
      }
      
      // Trending / What's hot - INSTANT
      if (msg.includes('trending') || msg.includes("what's hot") || msg.includes('whats hot') || msg.includes('popular bet') || msg.includes('everyone betting')) {
        const engagement = getEngagementContext();
        response = `**Trending Now**\n- ${engagement.liveBettersText}\n`;
        
        // Show top 3 trending picks only
        engagementData.trendingPicks.slice(0, 3).forEach((pick) => {
          response += `- ${pick.pick} (${pick.match}) - ${pick.betters} bets\n`;
        });
        
        quickActions = [
          { text: 'Get trending picks', action: 'give me picks on trending matches' },
          { text: 'Premier League picks', action: 'give me Premier League tips' },
          { text: 'More analysis', action: 'give me your best picks today' },
          { text: 'Play casino', action: 'show me casino games' },
        ];
        return { response, quickActions };
      }
      
      // Bonus check - INSTANT
      if (msg.includes('bonus') || msg.includes('free bet') || msg.includes('promotion')) {
        const bonus = getActiveBonus();
        if (bonus) {
          response = `**Your Bonus**\n- Type: ${bonus.label}\n- Amount: ZMW ${bonus.amount}\n- Expires: ${bonus.timeLeft}`;
          if (bonus.urgent) {
            response += `\n- STATUS: Expiring soon!`;
          }
        } else {
          response = "**Bonus Status**\n- No active bonuses\n- Check back for promotions";
        }
        quickActions = [
          { text: 'Use bonus now', action: 'help me use my bonus on a safe bet' },
          { text: 'Best picks today', action: 'show me best picks for my bonus' },
          { text: 'Casino bonus', action: 'can I use bonus on casino games' },
          { text: 'More analysis', action: 'give me more betting tips' },
        ];
        return { response, quickActions };
      }
      
      // ============================================
      // GREETINGS & COMMON MESSAGES
      // ============================================
      
      // Greetings - INSTANT
      const greetings = ['hi', 'hello', 'hey', 'yo', 'sup', 'hola', 'howdy', 'good morning', 'good afternoon', 'good evening', 'whats up', "what's up", 'wassup'];
      if (greetings.some(g => msg === g || msg === g + '!' || msg === g + '?')) {
        const engagement = getEngagementContext();
        const bonus = getActiveBonus();
        
        // Check if beginner or returning user
        const isNewUser = userMemory.experienceLevel === null;
        
        response = `**Welcome to BetAssist**\n- ${engagement.liveBettersText}`;
        if (engagement.trending) {
          response += `\n- Trending now: ${engagement.trending.pick}`;
        }
        if (bonus) {
          response += `\n- You have a ${bonus.label} (ZMW ${bonus.amount}) - use it!`;
        }
        
        // Contextual quick actions based on user type
        if (isNewUser) {
          quickActions = [
            { text: "I'm new to betting", action: "I'm new to betting, help me start" },
            { text: 'Winning sports bets', action: 'show me today\'s best picks' },
            { text: 'Easy casino game', action: 'recommend an easy casino game for beginners' },
            { text: 'Use my bonus', action: 'help me use my bonus' },
          ];
        } else {
          quickActions = [
            { text: 'Winning sports bets', action: 'show me today\'s best picks' },
            { text: 'Place a bet', action: 'help me place a bet' },
            { text: 'Play casino', action: 'show me hot casino games' },
            { text: 'Use my bonus', action: 'help me use my bonus' },
          ];
        }
        return { response, quickActions };
      }
      
      // How are you - INSTANT
      if (msg.includes('how are you') || msg.includes('how r u') || msg === 'hru') {
        const engagement = getEngagementContext();
        response = `**Ready to Help**\n- ${engagement.liveBettersText}\n- I can help you find winning bets`;
        quickActions = [
          { text: 'Winning sports bets', action: 'show me the hottest picks right now' },
          { text: 'Find safe bets', action: 'show me safe bets with good odds' },
          { text: 'Play casino', action: 'recommend a casino game' },
          { text: 'Place a bet', action: 'help me place a bet' },
        ];
        return { response, quickActions };
      }
      
      // Thanks - INSTANT
      if (msg === 'thanks' || msg === 'thank you' || msg === 'thx' || msg === 'ty') {
        const recentWin = getRecentWinner();
        response = `**You're welcome!**\n- Ready when you are\n- Recent win: ${recentWin.player} won ZMW ${recentWin.amount.toLocaleString()}`;
        quickActions = [
          { text: 'More picks', action: 'give me more winning picks' },
          { text: 'Play casino', action: 'show me a casino game' },
          { text: 'Different league', action: 'show me La Liga picks' },
          { text: 'Check bonuses', action: 'do I have any bonuses' },
        ];
        return { response, quickActions };
      }
      
      // Bye - INSTANT
      if (msg === 'bye' || msg === 'goodbye' || msg === 'see you' || msg === 'later' || msg === 'cya') {
        const bonus = getActiveBonus();
        response = "**See you soon!**\n- Good luck with your bets\n- Gamble responsibly";
        if (bonus) {
          response += `\n- Remember: ${bonus.label} expires ${bonus.timeLeft}`;
        }
        quickActions = [];
        return { response, quickActions };
      }
      
      // Help - INSTANT
      if (msg === 'help' || msg === '?' || msg === 'what can you do') {
        const engagement = getEngagementContext();
        response = "**BetAssist Features**\n" +
                   "- Match predictions\n" +
                   "- Casino strategies\n" +
                   "- Bonus tracking\n" +
                   `- ${engagement.liveBettersText}\n\n` +
                   "[MORE]I analyze 100+ leagues including Premier League, La Liga, NBA, NFL. I can help find winning bets and track your bonuses.[/MORE]";
        quickActions = [
          { text: 'Top picks', action: 'show me today\'s hottest picks' },
          { text: 'Play casino', action: 'which casino games are hot right now' },
          { text: 'My bonuses', action: 'what bonuses can I use' },
          { text: 'How betting works', action: 'explain how betting works' },
        ];
        return { response, quickActions };
      }
      
      // ============================================
      // SPORTS TIPS REQUESTS - Pass to Claude API for real data
      // ============================================
      
      // These patterns should NOT be instant - they need live data from Claude API
      // We return null to let them go through to the API
      const sportsLeaguePatterns = [
        'epl tips', 'premier league tips', 'la liga tips', 'serie a tips', 
        'bundesliga tips', 'champions league tips', 'nba tips', 'nfl tips',
        'mlb tips', 'nhl tips', 'sports tips', 'football tips', 'soccer tips',
        'basketball tips', 'tennis tips', 'ufc tips', 'boxing tips',
        'give me tips', 'betting tips', 'match tips', 'today tips',
        'tips for today', 'picks for today', 'predictions for today',
        'give me picks', 'give me predictions', 'best picks', 'best bets',
        'recommend bets', 'recommend picks', 'what should i bet',
        'games today', 'matches today', 'fixtures today',
        'who will win', 'who is playing'
      ];
      
      // If it's a sports tips request, let it go to Claude API (return null)
      if (sportsLeaguePatterns.some(p => msg.includes(p))) {
        return null; // Go to Claude API for live data
      }
      
      // Betting strategies request - offer both sports and casino
      if (msg.includes('betting strateg') || (msg.includes('strateg') && !hasCasinoKeyword && !casinoGameNames.some(g => msg.includes(g)))) {
        response = "**Strategies**\n" +
                   "- Value betting - Find +EV odds\n" +
                   "- Bankroll - Max 5% per bet\n" +
                   "- Form analysis - Recent results\n" +
                   "- Casino - Aviator, Blackjack, Roulette\n\n" +
                   "Ask \"explain [strategy]\" for details.";
        quickActions = [
          { text: 'Sports strategies', action: 'sports betting strategies explained' },
          { text: 'Casino strategies', action: 'casino strategies' },
          { text: 'Bankroll management', action: 'bankroll management tips' },
          { text: 'Value betting', action: 'explain value betting' },
        ];
        return { response, quickActions };
      }
      
      // Simple sport mentions
      if (msg === 'epl' || msg === 'premier league') {
        response = "**Premier League**\n- Data loaded\n- Ready for analysis";
        quickActions = [
          { text: 'Premier League tips', action: 'Premier League tips for today' },
          { text: 'Corner statistics', action: 'Premier League corner statistics' },
          { text: 'Goals statistics', action: 'Premier League goals statistics' },
          { text: 'League standings', action: 'Premier League standings' },
        ];
        return { response, quickActions };
      }
      
      if (msg === 'nba') {
        response = "**NBA**\n- Data loaded\n- Ready for analysis";
        quickActions = [
          { text: 'NBA tips', action: 'NBA tips for today' },
          { text: 'Team statistics', action: 'NBA team statistics' },
          { text: 'Standings', action: 'NBA standings' },
          { text: 'Other sports', action: 'show other sports' },
        ];
        return { response, quickActions };
      }
      
      if (msg === 'la liga') {
        response = "**La Liga**\n- Data loaded\n- Ready for analysis";
        quickActions = [
          { text: 'La Liga tips', action: 'La Liga tips for today' },
          { text: 'Corner statistics', action: 'La Liga corner statistics' },
          { text: 'Goals statistics', action: 'La Liga goals statistics' },
          { text: 'League standings', action: 'La Liga standings' },
        ];
        return { response, quickActions };
      }
      
      // Not a simple message - needs Claude API
      return null;
    }

    function askQuestion(question) {
      document.getElementById('messageInput').value = question;
      sendMessage();
    }

    // Strip all emojis from text
    function stripEmojis(text) {
      return text.replace(/[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]|[\u{1F900}-\u{1F9FF}]|[\u{1FA00}-\u{1FA6F}]|[\u{1FA70}-\u{1FAFF}]|[\u{231A}-\u{231B}]|[\u{23E9}-\u{23F3}]|[\u{23F8}-\u{23FA}]|[\u{25AA}-\u{25AB}]|[\u{25B6}]|[\u{25C0}]|[\u{25FB}-\u{25FE}]|[\u{2614}-\u{2615}]|[\u{2648}-\u{2653}]|[\u{267F}]|[\u{2693}]|[\u{26A1}]|[\u{26AA}-\u{26AB}]|[\u{26BD}-\u{26BE}]|[\u{26C4}-\u{26C5}]|[\u{26CE}]|[\u{26D4}]|[\u{26EA}]|[\u{26F2}-\u{26F3}]|[\u{26F5}]|[\u{26FA}]|[\u{26FD}]|[\u{2702}]|[\u{2705}]|[\u{2708}-\u{270D}]|[\u{270F}]|[\u{2712}]|[\u{2714}]|[\u{2716}]|[\u{271D}]|[\u{2721}]|[\u{2728}]|[\u{2733}-\u{2734}]|[\u{2744}]|[\u{2747}]|[\u{274C}]|[\u{274E}]|[\u{2753}-\u{2755}]|[\u{2757}]|[\u{2763}-\u{2764}]|[\u{2795}-\u{2797}]|[\u{27A1}]|[\u{27B0}]|[\u{27BF}]|[\u{2934}-\u{2935}]|[\u{2B05}-\u{2B07}]|[\u{2B1B}-\u{2B1C}]|[\u{2B50}]|[\u{2B55}]|[\u{3030}]|[\u{303D}]|[\u{3297}]|[\u{3299}]|[\u{FE0F}]|[\u{200D}]/gu, '').replace(/\s+/g, ' ').trim();
    }

    //  SPEED: Streaming-style message display (shows text progressively)
    // Now supports quickActions for clickable recommendations
    function addMessage(text, isUser, quickActions = []) {
      // Debug logging
      console.log('addMessage called:', { isUser, textPreview: text.substring(0, 50), quickActionsCount: quickActions.length });
      
      // Strip emojis from bot messages
      const cleanText = isUser ? text : stripEmojis(text);
      
      const container = document.getElementById('messages');
      const messageDiv = document.createElement('div');
      messageDiv.className = `flex ${isUser ? 'justify-end' : 'justify-start'} message-appear`;
      
      // Use timestamp + random to prevent ID collisions
      const uniqueId = Date.now() + '-' + Math.random().toString(36).substr(2, 9);
      const contentId = 'msg-' + uniqueId;
      const actionsId = 'actions-' + uniqueId;
      
      messageDiv.innerHTML = `
        <div class="max-w-[90%] rounded-2xl px-4 py-3 ${
          isUser 
            ? 'bg-gradient-to-r from-amber-500 to-orange-500 text-white rounded-br-sm'
            : 'bg-slate-800 text-slate-100 rounded-bl-sm border border-slate-700'
        }">
          ${!isUser ? `
            <div class="flex items-center gap-2 mb-2 pb-2 border-b border-slate-600">
              <div class="w-6 h-6 rounded-full bg-gradient-to-r from-amber-400 to-orange-500 flex items-center justify-center">
                <span class="text-xs"></span>
              </div>
              <span class="text-xs font-medium text-amber-400">BetAssist AI</span>
              <span class="text-xs text-slate-500">• Live Data</span>
            </div>
          ` : ''}
          <div id="${contentId}" class="text-sm whitespace-pre-wrap leading-relaxed"></div>
          <div id="${actionsId}"></div>
        </div>
      `;
      
      container.appendChild(messageDiv);
      messageDiv.scrollIntoView({ behavior: 'smooth' });
      
      const contentDiv = document.getElementById(contentId);
      const actionsDiv = document.getElementById(actionsId);
      
      // Show text content (with emojis stripped for bot)
      contentDiv.innerHTML = formatText(cleanText);
      
      // Add quick action buttons if provided (only for AI messages)
      if (!isUser && quickActions && quickActions.length > 0) {
        actionsDiv.innerHTML = generateQuickActionsHTML(quickActions);
      }
      
      // Scroll to show the message
      setTimeout(() => {
        messageDiv.scrollIntoView({ behavior: 'smooth', block: 'end' });
      }, 100);
    }

    //  SPEED: Simulate streaming by showing text progressively
    function streamText(element, text, speed = 5) {
      const formatted = formatText(text);
      let index = 0;
      const chunkSize = 3; // Characters per frame
      
      function showNextChunk() {
        if (index < formatted.length) {
          // Find a good break point (don't break mid-tag)
          let end = Math.min(index + chunkSize, formatted.length);
          
          // Don't break in the middle of an HTML tag
          const remaining = formatted.substring(index);
          const tagStart = remaining.indexOf('<');
          const tagEnd = remaining.indexOf('>');
          
          if (tagStart >= 0 && tagStart < chunkSize && tagEnd > tagStart) {
            end = index + tagEnd + 1;
          }
          
          element.innerHTML = formatted.substring(0, end);
          index = end;
          
          // Scroll to keep up with text
          element.parentElement.parentElement.scrollIntoView({ behavior: 'smooth', block: 'end' });
          
          requestAnimationFrame(showNextChunk);
        }
      }
      
      requestAnimationFrame(showNextChunk);
    }

    // Original addMessage for backwards compatibility
    function addMessageInstant(text, isUser) {
      const container = document.getElementById('messages');
      const messageDiv = document.createElement('div');
      messageDiv.className = `flex ${isUser ? 'justify-end' : 'justify-start'} message-appear`;
      
      messageDiv.innerHTML = `
        <div class="max-w-[90%] rounded-2xl px-4 py-3 ${
          isUser 
            ? 'bg-gradient-to-r from-amber-500 to-orange-500 text-white rounded-br-sm'
            : 'bg-slate-800 text-slate-100 rounded-bl-sm border border-slate-700'
        }">
          ${!isUser ? `
            <div class="flex items-center gap-2 mb-2 pb-2 border-b border-slate-600">
              <div class="w-6 h-6 rounded-full bg-gradient-to-r from-amber-400 to-orange-500 flex items-center justify-center">
                <span class="text-xs"></span>
              </div>
              <span class="text-xs font-medium text-amber-400">BetAssist AI</span>
              <span class="text-xs text-slate-500">• Live Data</span>
            </div>
          ` : ''}
          <div class="text-sm whitespace-pre-wrap leading-relaxed">${formatText(text)}</div>
        </div>
      `;
      
      container.appendChild(messageDiv);
      messageDiv.scrollIntoView({ behavior: 'smooth' });
    }

    function formatText(text) {
      // FORCE LINE BREAKS - Post-process AI response
      let formatted = text;
      
      // Split matches: Add double line break before **Team vs Team**
      formatted = formatted.replace(/\s*\*\*([A-Z][a-zA-Z\s]+ vs [A-Z][a-zA-Z\s]+)\*\*/g, '\n\n**$1**');
      formatted = formatted.replace(/\s*\*\*([A-Z][a-zA-Z\s]+vs [A-Z][a-zA-Z\s]+)\*\*/g, '\n\n**$1**');
      
      // Add line break after time (e.g., "10:00 AM EST -" or "7:30 PM -")
      formatted = formatted.replace(/(\d{1,2}:\d{2}\s*[AP]M(?:\s*[A-Z]{2,3})?)\s*-\s*/g, '$1\n- ');
      
      // Split picks: percentage followed by dash and capital letter = new line
      formatted = formatted.replace(/(\d+%)\s*-\s*([A-Z])/g, '$1\n- $2');
      
      // "Best:" should be on its own line and end the match section
      formatted = formatted.replace(/\s*-?\s*Best:\s*/g, '\n- Best: ');
      formatted = formatted.replace(/(Best:[^*\n]+?)(\s*\*\*)/g, '$1\n\n$2');
      formatted = formatted.replace(/(Best:[^T\n]+?)(TRENDING|BONUS)/g, '$1\n\n$2');
      
      // BONUS ALERT, TRENDING on new line
      formatted = formatted.replace(/([a-z%])\s*(BONUS ALERT|TRENDING)/g, '$1\n\n$2');
      
      // Clean up: remove leading newlines, fix multiple newlines
      formatted = formatted.replace(/^\n+/, '');
      formatted = formatted.replace(/\n{3,}/g, '\n\n');
      
      console.log('FORMATTED TEXT:', formatted);
      
      return formatted
        // Expandable "More Info" dropdown - [MORE]content[/MORE]
        .replace(/\[MORE\]([\s\S]*?)\[\/MORE\]/g, '<details class="more-info"><summary>Why this recommendation?</summary><div class="more-info-content">$1</div></details>')
        // Bold
        .replace(/\*\*(.*?)\*\*/g, '<strong class="text-amber-300">$1</strong>')
        // Links
        .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" class="text-amber-400 hover:underline">$1</a>')
        // Line breaks
        .replace(/\n/g, '<br>');
    }

    function addWelcomeMessage() {
      // Get player summary
      const profile = getPlayerSummaryForAI();
      const isReturning = profile.behavior.totalInteractions > 0;
      const hasFavorites = profile.preferences.favoriteLeagues.length > 0;
      const hasHistory = profile.performance.totalBets > 0;
      const engagement = getEngagementContext();

      let welcomeText = `**Welcome to BetAssist!**\n\n`;
      welcomeText += `I'm here to help you win.\n\n`;
      welcomeText += `What do you prefer?`;

      // Initial choice - Sports, Casino, or More Info
      let welcomeActions = [
        { text: 'Sports Betting', action: 'I want to try sports betting' },
        { text: 'Casino Games', action: 'I want to play casino games' },
      ];

      addMessage(welcomeText, false, welcomeActions);
    }

    // Handle user's initial preference choice
    function handleUserPreferenceChoice(choice) {
      const choiceLower = choice.toLowerCase();
      
      // Only match EXACT onboarding phrases, not general queries
      const sportsOnboarding = [
        'i want to try sports betting',
        'i want sports betting',
        'sports betting please',
      ];
      
      const casinoOnboarding = [
        'i want to play casino games',
        'i want casino games',
        'casino games please',
      ];
      
      const simpleMode = [
        'keep it simple for me',
        'keep it simple',
        'simple please',
      ];
      
      const proMode = [
        'give me the full analysis',
        'give me advanced strategies',
        'in-depth please',
        'full analysis',
        'advanced strategies',
      ];
      
      // Check for sports onboarding
      if (sportsOnboarding.some(phrase => choiceLower.includes(phrase))) {
        setUserPreference('sports');
        setTimeout(() => {
          const response = `**Sports Betting!**\n\n` +
            `How do you want me to explain things?\n\n` +
            `**Simple:** I'll explain everything like you're new to betting. One clear pick with step-by-step instructions.\n\n` +
            `**In-Depth:** Full stats, multiple options, betting jargon included.`;
          
          addMessage(response, false, [
            { text: 'Keep it Simple', action: 'Keep it simple for me' },
            { text: 'In-Depth Analysis', action: 'Give me the full analysis' },
          ]);
        }, 300);
        return true;
      }
      
      // Check for casino onboarding
      if (casinoOnboarding.some(phrase => choiceLower.includes(phrase))) {
        setUserPreference('casino');
        setTimeout(() => {
          const response = `**Casino Games!**\n\n` +
            `How do you want me to explain things?\n\n` +
            `**Simple:** Easy explanations of how each game works. Perfect if you're new.\n\n` +
            `**In-Depth:** Advanced strategies, payout rates, and pro tactics.`;
          
          addMessage(response, false, [
            { text: 'Keep it Simple', action: 'Keep it simple for me' },
            { text: 'In-Depth Strategy', action: 'Give me advanced strategies' },
          ]);
        }, 300);
        return true;
      }
      
      // Check for simple mode selection
      if (simpleMode.some(phrase => choiceLower === phrase || choiceLower.includes(phrase))) {
        setUserMode('beginner');
        setTimeout(() => {
          if (userPreference === 'casino') {
            showCasinoIntro();
          } else {
            showFirstSportsPick();
          }
        }, 300);
        return true;
      }
      
      // Check for pro mode selection - but ONLY if it's the exact phrase, not part of a longer query
      if (proMode.some(phrase => choiceLower === phrase)) {
        setUserMode('pro');
        setTimeout(() => {
          if (userPreference === 'casino') {
            showCasinoIntro();
          } else {
            showFirstSportsPick();
          }
        }, 300);
        return true;
      }
      
      return false;
    }
    
    // Show first sports pick based on mode
    function showFirstSportsPick() {
      let response = '';
      
      if (userMode === 'beginner') {
        response = `**Here's my pick for you:**\n\n`;
        response += `**Match:** Liverpool vs Arsenal\n`;
        response += `**Time:** 8:00 PM tonight\n\n`;
        response += `**My Pick:** Both teams score at least 1 goal\n`;
        response += `This is called "BTTS Yes" (Both Teams To Score - Yes)\n\n`;
        response += `**Confidence:** Very Likely\n\n`;
        response += `**Why this pick?**\n`;
        response += `Both Liverpool and Arsenal have strong attacks. When they play each other, goals happen! In their last 5 matches, both teams scored every single time.\n\n`;
        response += `**How to place this bet:**\n`;
        response += `1. Open Bwanabet and go to Sports → Football → Premier League\n`;
        response += `2. Find "Liverpool vs Arsenal"\n`;
        response += `3. Look for "Both Teams to Score" and tap "Yes"\n`;
        response += `4. Enter your bet amount (start small, like ZMW 10-20)\n`;
        response += `5. Tap "Place Bet" to confirm\n\n`;
        response += `**Ready to go?**`;
        
        addMessage(response, false, [
          { text: 'Show me how to find this', action: 'show me exactly where to find Both Teams to Score on Bwanabet' },
          { text: 'Give me a different pick', action: 'show me an easier or safer pick' },
          { text: 'Explain BTTS more', action: 'explain what Both Teams to Score means in more detail' },
          { text: 'Try casino instead', action: 'show me casino games' },
        ]);
      } else {
        response = `**Top Value Pick:**\n\n`;
        response += `**Liverpool vs Arsenal** - 20:00\n\n`;
        response += `| Market | Odds | Confidence |\n`;
        response += `|--------|------|------------|\n`;
        response += `| BTTS Yes | 1.72 | 72% |\n`;
        response += `| Over 2.5 | 1.85 | 68% |\n`;
        response += `| Liverpool ML | 2.10 | 55% |\n\n`;
        response += `**Best Value:** BTTS Yes @ 1.72\n\n`;
        response += `**Analysis:** H2H shows BTTS landing in 8/10 recent meetings. Liverpool xG: 2.1, Arsenal xG: 1.8. High-tempo match expected.\n\n`;
        response += `**Ready to go?**`;
        
        addMessage(response, false, [
          { text: 'Deep dive analysis', action: 'give me full statistical breakdown of Liverpool vs Arsenal' },
          { text: 'More matches', action: 'show me all Premier League picks for today' },
          { text: 'Other leagues', action: 'show me La Liga or Serie A picks' },
          { text: 'Try casino', action: 'show me casino games' },
        ]);
      }
    }
    
    // Show casino intro based on mode
    function showCasinoIntro() {
      let response = '';
      
      if (userMode === 'beginner') {
        response = `**Let's start with the easiest game: Aviator**\n\n`;
        response += `**What is Aviator?**\n`;
        response += `It's a simple game where a little plane takes off. As it flies, a number (called "multiplier") goes up:\n`;
        response += `1.00x → 1.50x → 2.00x → 3.00x → and higher...\n\n`;
        response += `**How do you win?**\n`;
        response += `Press the "Cash Out" button BEFORE the plane flies away! If you cash out at 2.00x, you win 2 times your bet. But if the plane flies away before you press it, you lose.\n\n`;
        response += `**My beginner strategy:**\n`;
        response += `Always cash out at 1.50x. You won't win big, but you'll win often. This builds your balance safely.\n\n`;
        response += `**Ready to go?**`;
        
        addMessage(response, false, [
          { text: 'Where is Aviator?', action: 'show me exactly where to find Aviator on Bwanabet' },
          { text: 'Show me a different game', action: 'recommend a different easy casino game' },
          { text: 'More Aviator tips', action: 'give me more tips to win at Aviator' },
          { text: 'Try sports betting', action: 'show me sports betting picks' },
        ]);
      } else {
        response = `**Casino Games - Best RTP:**\n\n`;
        response += `| Game | RTP | Type |\n`;
        response += `|------|-----|------|\n`;
        response += `| Blackjack | 99.5% | Table |\n`;
        response += `| European Roulette | 97.3% | Table |\n`;
        response += `| Aviator | 97.0% | Crash |\n`;
        response += `| Video Poker | 96.5% | Cards |\n\n`;
        response += `**Recommended:** Blackjack with basic strategy offers the best mathematical edge.\n\n`;
        response += `**Ready to go?**`;
        
        addMessage(response, false, [
          { text: 'Blackjack strategy', action: 'teach me optimal blackjack basic strategy' },
          { text: 'Aviator strategies', action: 'show me advanced Aviator betting patterns' },
          { text: 'Compare all games', action: 'compare all casino games by RTP and volatility' },
          { text: 'Try sports betting', action: 'show me sports betting picks' },
        ]);
      }
    }

    // ============================================
    // INITIALIZATION
    // ============================================

    // Pre-fetched data for instant responses
    let prefetchedData = {
      leagues: {},
      lastFetch: null,
    };

    // Pre-fetch popular leagues in background for instant responses
    async function prefetchPopularData() {
      const popularLeagues = ['eng.1', 'esp.1', 'ger.1', 'ita.1', 'nba', 'nfl'];
      
      console.log(' Pre-fetching popular league data...');
      
      // Fetch all in parallel for speed
      const promises = popularLeagues.map(async (league) => {
        try {
          const data = await fetchGames(league);
          if (!data.error) {
            prefetchedData.leagues[league] = data;
          }
        } catch (e) {
          // Silently fail - this is just optimization
        }
      });

      // Don't wait - let it run in background
      Promise.all(promises).then(() => {
        prefetchedData.lastFetch = Date.now();
        console.log(' Pre-fetch complete:', Object.keys(prefetchedData.leagues).length, 'leagues cached');
      });
    }

    // Initialize the app
    async function initializeApp() {
      // Initialize Supabase first
      await initSupabase();
      
      // Load player data (from Supabase or localStorage)
      playerData = await loadPlayerData();
      console.log(' Player data loaded:', playerData.profile.username || 'Guest');
      
      // Show welcome message
      addWelcomeMessage();
      
      // Pre-fetch popular data in background (non-blocking)
      prefetchPopularData();
      
      // Show connection status
      if (supabaseClient && currentPlayerId) {
        console.log(' Connected to Supabase database');
      } else {
        console.log(' Running in demo mode (localStorage)');
      }
    }

    // Expose functions globally for onclick handlers
    window.sendMessage = sendMessage;
    window.clearChat = clearChat;
    window.askQuestion = askQuestion;

    window.onload = async function() {
      console.log(' BetAssist AI Starting...');
      console.log(' Using Supabase proxy:', SUPABASE_CONFIG.claudeProxyUrl);
      
      try {
        await initializeApp();
        console.log(' BetAssist AI Ready!');
      } catch (error) {
        console.error(' Initialization failed:', error);
        document.getElementById('messages').innerHTML = `
          <div class="bg-red-500/20 border border-red-500 rounded-xl p-4 text-red-200">
            <strong> Initialization Error</strong><br>
            ${error.message}<br>
            <small>Check browser console for details</small>
          </div>
        `;
      }
    };
  </script>
</body>
</html>
